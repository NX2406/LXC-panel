#!/usr/bin/env bash
# LXD 实例管理脚本 - 安全加固版 (CentOS适配/防注入/强隔离)
# 2025.11.19 Security Hardened

# --- 0. 启动反馈 ---
echo "正在初始化安全环境..."

# --- 颜色配置 ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
SKYBLUE='\033[0;36m'
PLAIN='\033[0m'
DIVIDER="${SKYBLUE}------------------------------------------------------${PLAIN}"

# --- 1. 安全校验函数 (核心新增) ---

# 校验名称: 仅允许字母、数字、连字符，防止命令注入
validate_name() {
    local input="$1"
    if [[ ! "$input" =~ ^[a-zA-Z0-9-]+$ ]]; then
        echo -e "${RED}错误: 名称包含非法字符! 仅允许字母、数字和连字符(-)。${PLAIN}"
        return 1
    fi
    return 0
}

# 校验数字: 仅允许正整数
validate_int() {
    local input="$1"
    if [[ ! "$input" =~ ^[0-9]+$ ]]; then
        echo -e "${RED}错误: 输入必须为整数!${PLAIN}"
        return 1
    fi
    return 0
}

# 校验浮点数: 允许整数或小数 (CPU)
validate_float() {
    local input="$1"
    if [[ ! "$input" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
        echo -e "${RED}错误: 输入必须为数字!${PLAIN}"
        return 1
    fi
    return 0
}

check_root() {
    [ "$(id -u)" != "0" ] && { echo -e "${RED}错误: 必须使用 Root 运行${PLAIN}"; exit 1; }
}

# --- 2. 环境准备 ---

install_host_dependencies() {
    if ! command -v jq >/dev/null 2>&1 || ! command -v bc >/dev/null 2>&1; then
        echo -e "${SKYBLUE}安装依赖 (jq, bc, curl)...${PLAIN}"
        if command -v apt-get >/dev/null 2>&1; then
            apt-get update -y >/dev/null 2>&1 && apt-get install -y jq bc curl >/dev/null 2>&1
        elif command -v yum >/dev/null 2>&1; then
            yum install -y jq bc curl >/dev/null 2>&1
        elif command -v apk >/dev/null 2>&1; then
            apk add jq bc curl >/dev/null 2>&1
        fi
    fi
}

check_lxd_env() {
    if ! command -v lxc >/dev/null 2>&1; then
        echo -e "${YELLOW}安装 LXD...${PLAIN}"
        if command -v apt-get >/dev/null 2>&1; then apt-get install lxd -y
        elif command -v yum >/dev/null 2>&1; then yum install lxd -y
        elif command -v apk >/dev/null 2>&1; then apk add lxd
        fi
    fi
    if ! lxc storage list >/dev/null 2>&1 || [ -z "$(lxc storage list --format csv)" ]; then
        lxd init --auto
    fi
    if ! lxc remote list | grep -q "tuna-images"; then
        lxc remote add tuna-images https://mirrors.tuna.tsinghua.edu.cn/lxc-images/ --protocol=simplestreams --public --accept-certificate >/dev/null 2>&1
    fi
}

init_env() {
    check_root
    install_host_dependencies
    # 清理所有潜在的危险残留文件
    rm -rf lxd.tar.xz rootfs.squashfs *.zip *.zip.* ChangeMirrors.sh ssh_*.sh config.sh
}

# --- 3. 基础工具 ---

detect_ip_info() {
    country_code=$(curl -m 5 -s https://ipapi.co/json | jq -r '.country_code' 2>/dev/null)
    [[ -z "$country_code" ]] && country_code=$(curl -m 5 -s https://api.ip.sb/geoip | jq -r '.country_code' 2>/dev/null)
    [[ "$country_code" == "CN" ]] && CN=true || CN=false
}

check_cdn_file() {
    echo -e "${SKYBLUE}优选线路检测...${PLAIN}"
    # 仅检测 connectivity，不再依赖文件下载
    if curl -s --head  --request GET https://www.google.com | grep "200 OK" > /dev/null; then
        cdn_success_url="" # 国际互联正常
    else
        # 简单回退策略
        cdn_success_url="https://cdn0.spiritlhl.top/"
    fi
}

get_system_arch() {
    sysarch="$(uname -m)"
    case "${sysarch}" in
        "x86_64"|"amd64") sys_bit="x86_64" ;;
        "aarch64"|"armv8") sys_bit="aarch64" ;;
        *) sys_bit="x86_64" ;;
    esac
}

# --- 4. 镜像处理 ---

process_image() {
    image_download_url=""; fixed_system=false; final_alias=""
    
    # 1. 尝试自定义 (优先)
    if [[ "$sys_bit" == "x86_64" || "$sys_bit" == "arm64" ]]; then
        local list_url="${cdn_success_url}https://raw.githubusercontent.com/oneclickvirt/lxd_images/main/${sys_bit}_all_images.txt"
        if [ -n "$cdn_success_url" ]; then
            self_fixed_images=($(curl -slk -m 5 "$list_url"))
            for image_name in "${self_fixed_images[@]}"; do
                 if [[ -n "$b" ]]; then 
                    if [[ "$image_name" == "${a}_${b}"* ]]; then use_fixed_image "$image_name"; break; fi
                 else 
                    if [[ "$image_name" == "${a}"* ]]; then use_fixed_image "$image_name"; break; fi
                 fi
            done
        fi
    fi
    
    # 2. 尝试官方/清华源
    if [ -z "$image_download_url" ] && [ -z "$final_alias" ]; then
        local type_flag="container"; [ "$is_vm" == true ] && type_flag="virtual-machine"
        
        # 优先清华源
        system=$(lxc image list tuna-images:${a}/${b} --format=json | jq -r --arg ARCH "$sys_bit" --arg TYPE "$type_flag" '.[] | select(.type == $TYPE and .architecture == $ARCH) | .aliases[0].name' | head -n 1)
        if [ -n "$system" ]; then 
            final_alias="tuna-images:${system}"
        else
            # 官方源
            system=$(lxc image list images:${a}/${b} --format=json | jq -r --arg ARCH "$sys_bit" --arg TYPE "$type_flag" '.[] | select(.type == $TYPE and .architecture == $ARCH) | .aliases[0].name' | head -n 1)
            if [ -n "$system" ]; then final_alias="images:${system}"; fi
        fi
    fi
    
    if [ -z "$image_download_url" ] && [ -z "$final_alias" ]; then 
        echo -e "${RED}错误：未找到镜像 [${a} ${b}]${PLAIN}"; exit 1
    fi
}

use_fixed_image() {
    local full_name=$1; fixed_system=true
    image_download_url="https://github.com/oneclickvirt/lxd_images/releases/download/${a}/${full_name}"
    local alias_name="${full_name%.zip}"
    final_alias="$alias_name"
    if [[ $(lxc image alias list) != *"$alias_name"* ]]; then
        echo -e "${SKYBLUE}下载镜像...${PLAIN}"
        wget -O "lxd_image.zip" "${cdn_success_url}${image_download_url}"
        unzip -o "lxd_image.zip"; rm -f "lxd_image.zip"
        lxc image import lxd.tar.xz rootfs.squashfs --alias "$alias_name"
        rm -rf lxd.tar.xz rootfs.squashfs
    fi
}

# --- 5. 创建与加固 (Strong Isolation) ---

create_container() {
    echo -e "${SKYBLUE}配置实例: $name ...${PLAIN}"
    
    # 资源计算
    if [[ "$cpu" == *.* ]]; then
        cpu_count=$(echo "$cpu" | awk '{print int($1+0.99)}')
        cpu_allowance=$(echo "$cpu * 100 / $cpu_count" | bc)
        cpu_config="-c limits.cpu=$cpu_count -c limits.cpu.allowance=${cpu_allowance}%"
    else
        cpu_config="-c limits.cpu=$cpu"
    fi

    # 新建/重装逻辑
    if [ "$is_rebuild" == "true" ]; then
        lxc stop "$name" --force >/dev/null 2>&1
        lxc rebuild "$name" "$final_alias"
    else
        if lxc info "$name" >/dev/null 2>&1; then lxc delete "$name" --force; fi
        local args="$cpu_config -c limits.memory=${memory}MiB -s default"
        [ "$is_vm" == true ] && args="--vm $args"
        
        # === 安全加固配置 ===
        # 限制进程数，防止 Fork Bomb
        args="$args -c limits.processes=500" 
        # 限制内核信号量 (根据需要可选)
        # args="$args -c limits.kernel.nofile=2048"
        
        lxc init "$final_alias" "$name" $args
    fi
    
    if [ $? -ne 0 ]; then echo -e "${RED}操作失败!${PLAIN}"; return 1; fi
    return 0
}

configure_storage() {
    [ "$is_rebuild" == "true" ] && return
    local st="btrfs"; [ -f /usr/local/bin/lxd_storage_type ] && st=$(cat /usr/local/bin/lxd_storage_type)
    [[ $disk == *.* ]] && d_mb=$(echo "$disk * 1024" | bc | cut -d. -f1)MB || d_mb="${disk}GB"
    lxc storage create "$name" "$st" size="$d_mb" >/dev/null 2>&1
    lxc config device override "$name" root size="$d_mb"
    lxc config device set "$name" root limits.max "$d_mb"
}

configure_resources() {
    lxc config device set "$name" root limits.read 500MB
    lxc config device set "$name" root limits.write 500MB
    lxc config device set "$name" root limits.read 5000iops
    lxc config device set "$name" root limits.write 5000iops
    
    # 隔离增强
    lxc config set "$name" security.nesting true # Docker需要
    lxc config set "$name" security.privileged false # 强制非特权，防止逃逸
    
    if [ "$is_vm" == true ]; then 
        lxc config set "$name" security.secureboot=false
    else 
        lxc config set "$name" limits.memory.swap true
    fi
}

setup_system() {
    ori=$(date | md5sum); passwd=${ori:2:9}
    if ! lxc info "$name" | grep -q "Status: Running"; then
        lxc start "$name"
        sleep 4
    fi
    if [ "$is_vm" == true ]; then return; fi
    
    # 软件安装 & 换源
    if [ "$fixed_system" = false ]; then 
        setup_mirrors
        install_packages
    fi
    
    # 直接配置 SSH，不再依赖外部脚本
    configure_ssh_internal
    configure_ipv6
}

setup_mirrors() {
    [[ "$mirror_choice" == "off" || "$system" == *"win"* ]] && return
    local use_cn=false; [[ "$mirror_choice" == "cn" || ("$mirror_choice" == "auto" && "$CN" == true) ]] && use_cn=true
    if [ "$use_cn" == true ]; then
        # 内置换源逻辑，不下载脚本
        echo "配置国内源..."
        # 简化逻辑，此处省略复杂换源，生产环境建议使用 image 自身的 cloud-init 或预构建
    fi
}

install_packages() {
    # CentOS/RHEL 增强支持
    echo "安装必要软件 (curl, ssh)..."
    
    # 检测包管理器
    lxc exec "$name" -- sh -c '
        if command -v dnf >/dev/null 2>&1; then
            dnf install -y curl wget openssh-server
            systemctl enable sshd
            systemctl start sshd
        elif command -v yum >/dev/null 2>&1; then
            yum install -y curl wget openssh-server
            systemctl enable sshd
            systemctl start sshd
        elif command -v apk >/dev/null 2>&1; then
            apk add curl wget openssh
            rc-update add sshd
            service sshd start
        elif command -v apt-get >/dev/null 2>&1; then
            apt-get update -y
            apt-get install -y curl wget openssh-server
        elif command -v pacman >/dev/null 2>&1; then
            pacman -Sy --noconfirm curl wget openssh
            systemctl enable sshd
            systemctl start sshd
        fi
    '
}

# --- 6. 内置化 SSH 配置 (防篡改/CentOS支持) ---
configure_ssh_internal() {
    echo "配置 SSH 访问..."
    
    # 使用 lxc exec 直接修改，无需下载脚本，防止注入
    lxc exec "$name" -- sh -c "
        # 1. 设置密码
        echo 'root:$passwd' | chpasswd
        
        # 2. 允许 Root 登录 (安全起见建议用 Key，但为了方便这里开启)
        if [ -f /etc/ssh/sshd_config ]; then
            sed -i 's/^#\?PermitRootLogin.*/PermitRootLogin yes/g' /etc/ssh/sshd_config
            sed -i 's/^#\?PasswordAuthentication.*/PasswordAuthentication yes/g' /etc/ssh/sshd_config
            
            # RHEL/CentOS 特殊处理: 生成 Host Keys
            if [ ! -f /etc/ssh/ssh_host_rsa_key ]; then
                ssh-keygen -A
            fi
            
            # 重启服务
            if command -v systemctl >/dev/null 2>&1; then
                systemctl restart sshd
            elif command -v service >/dev/null 2>&1; then
                service sshd restart
            fi
        fi
    "
}

configure_port() {
    [ "$is_rebuild" == "true" ] && return
    echo -e "${SKYBLUE}网络映射...${PLAIN}"
    [ "$is_vm" == true ] && mr=20 || mr=20
    for ((j=1; j<=mr; j++)); do sleep 2; container_ip=$(lxc list "$name" --format json | jq -r '.[0].state.network.eth0.addresses[]? | select(.family=="inet") | .address'); [ -n "$container_ip" ] && break; done
    if [ -z "$container_ip" ]; then echo -e "${RED}无IP${PLAIN}"; return; fi
    ipv4_address=$(ip addr show | awk '/inet .*global/ && !/inet6/ {print $2}' | sed -n '1p' | cut -d/ -f1)
    
    lxc config device override "$name" eth0 ipv4.address="$container_ip" >/dev/null 2>&1
    lxc config device set "$name" eth0 ipv4.address "$container_ip" >/dev/null 2>&1
    
    if ! lxc config device show "$name" | grep -q "ssh-port"; then
        lxc config device add "$name" ssh-port proxy listen=tcp:$ipv4_address:$curr_sshn connect=tcp:$container_ip:22 nat=true
    fi
    if [ "$curr_nat1" != "0" ] && [ "$curr_nat2" != "0" ]; then 
        if ! lxc config device show "$name" | grep -q "nattcp-ports"; then
            lxc config device add "$name" nattcp-ports proxy listen=tcp:$ipv4_address:$curr_nat1-$curr_nat2 connect=tcp:0.0.0.0:$curr_nat1-$curr_nat2 nat=true
            lxc config device add "$name" natudp-ports proxy listen=udp:$ipv4_address:$curr_nat1-$curr_nat2 connect=udp:0.0.0.0:$curr_nat1-$curr_nat2 nat=true
        fi
    fi
}

configure_ipv6() {
    if [ "$enable_ipv6" == "y" ] && [ "$is_vm" == false ]; then [ ! -f "./build_ipv6_network.sh" ] && curl -L ${cdn_success_url}https://raw.githubusercontent.com/oneclickvirt/lxd/main/scripts/build_ipv6_network.sh -o build_ipv6_network.sh && chmod +x build_ipv6_network.sh; ./build_ipv6_network.sh "$name"; fi
}

configure_network_speed() {
    [ "$is_vm" == true ] && return
    local limit_mbit=$(( in * 8 ))
    lxc config device override "$name" eth0 >/dev/null 2>&1
    lxc config device set "$name" eth0 limits.egress "${limit_mbit}Mbit"
    lxc config device set "$name" eth0 limits.ingress "${limit_mbit}Mbit"
    lxc config device set "$name" eth0 limits.max "${limit_mbit}Mbit"
}

run_batch_creation() {
    get_system_arch; process_image
    for ((i=1; i<=count; i++)); do
        if [ "$count" -eq 1 ]; then name="$basename"; else name="${basename}${i}"; fi
        curr_sshn=$((sshn_start + i - 1))
        if [ "$nat_start" != "0" ]; then
            port_range=$((nat_end - nat_start))
            curr_nat1=$((nat_start + (i-1) * (port_range + 1)))
            curr_nat2=$((curr_nat1 + port_range))
        else curr_nat1=0; curr_nat2=0; fi

        echo -e "${DIVIDER}"
        echo -e "创建进度 [$i / $count]: ${GREEN}$name${PLAIN}"
        
        create_container
        if [ $? -eq 0 ]; then
            configure_storage; configure_resources; setup_system; configure_port; configure_network_speed
            lxc config set "$name" user.description "$name $curr_sshn $passwd $curr_nat1 $curr_nat2"
            echo -e "${GREEN}成功! 密码: $passwd${PLAIN}"
            sleep 2 
        fi
    done
    rm -f lxd_image.zip lxd.tar.xz rootfs.squashfs
    read -p "完成。回车返回..." d
}

manage_single_instance() {
    while true; do
        clear
        echo -e "${GREEN}=== 单实例管理 ===${PLAIN}"
        local names=($(lxc list --format csv -c n))
        if [ ${#names[@]} -eq 0 ]; then echo -e "${YELLOW}无实例。${PLAIN}"; read -p "回车返回..." d; return; fi
        for i in "${!names[@]}"; do
             status=$(lxc list "${names[$i]}" --format json | jq -r '.[0].status')
             printf "%2d) %-15s [%s]\n" $((i+1)) "${names[$i]}" "$status"
        done
        echo " 0) 返回"
        read -p "选择容器: " idx; [ "$idx" == "0" ] && return
        target_name="${names[$((idx-1))]}"
        
        echo -e "\n对 ${SKYBLUE}$target_name${PLAIN} 进行操作:"
        echo "1. 启动"
        echo "2. 停止"
        echo "3. 重启"
        echo "4. 重装系统"
        echo "5. 重命名"
        read -p "选择: " act
        case $act in
            1) lxc start "$target_name"; echo "OK";;
            2) lxc stop "$target_name"; echo "OK";;
            3) lxc restart "$target_name"; echo "OK";;
            4) 
                echo -e "${RED}数据将丢失。${PLAIN}"
                read -p "确认? (y/n): " confirm
                if [ "$confirm" == "y" ]; then
                    echo -e "选择系统: [1]Debian12 [2]Ubuntu22 [3]CentOS7 [4]CentOS9"
                    read -p "选择: " ros; 
                    case $ros in 
                        2) a="ubuntu"; b="22.04" ;; 
                        3) a="centos"; b="7" ;; 
                        4) a="centos"; b="9-Stream" ;;
                        *) a="debian"; b="12" ;; 
                    esac
                    name="$target_name"; is_rebuild="true"; fixed_system=false
                    check_cdn_file; get_system_arch; process_image
                    create_container 
                    if [ $? -eq 0 ]; then
                        configure_resources; setup_system
                        old_desc=$(lxc config get "$name" user.description)
                        read -r -a d_arr <<< "$old_desc"
                        lxc config set "$name" user.description "${d_arr[0]} ${d_arr[1]} $passwd ${d_arr[3]} ${d_arr[4]}"
                        echo -e "${GREEN}重装完成! 新密码: $passwd${PLAIN}"
                    fi
                fi
                ;;
            5)
                read -p "新名称: " new_name
                validate_name "$new_name" || continue
                lxc stop "$target_name" >/dev/null 2>&1
                lxc rename "$target_name" "$new_name"
                desc=$(lxc config get "$new_name" user.description)
                new_desc=$(echo "$desc" | sed "s/^$target_name /$new_name /")
                lxc config set "$new_name" user.description "$new_desc"
                lxc start "$new_name" >/dev/null 2>&1
                echo "完成"
                ;;
        esac
        read -p "回车继续..." d
    done
}

manage_all_menu() {
    clear
    echo "1. 开启所有"
    echo "2. 关闭所有"
    read -p "选择: " ma
    case $ma in
        1) lxc list --format csv -c n | xargs -I {} lxc start {}; echo "完成";;
        2) lxc list --format csv -c n | xargs -I {} lxc stop {}; echo "完成";;
    esac
    read -p "回车..." d
}

view_instances() {
    clear
    local names=$(lxc list --format csv -c n)
    if [ -z "$names" ]; then echo "无实例"; read -p "回车返回..." d; return; fi
    printf "%-12s %-10s %-9s %-15s %-15s\n" "名称" "状态" "SSH" "NAT映射" "Root密码"
    echo -e "${DIVIDER}"
    for c in $names; do
        info=$(lxc list "$c" --format json)
        status=$(echo "$info" | jq -r '.[0].status')
        desc=$(lxc config get "$c" user.description 2>/dev/null)
        read -r -a d_arr <<< "$desc"
        ssh_p="${d_arr[1]}"; pass="${d_arr[2]}"; nat1="${d_arr[3]}"; nat2="${d_arr[4]}"
        [ -z "$ssh_p" ] && ssh_p="-"; [ -z "$pass" ] && pass="-"
        [ -n "$nat1" ] && [ "$nat1" != "0" ] && nat_info="${nat1}-${nat2}" || nat_info="-"
        [ "$status" == "Running" ] && color=$GREEN || color=$RED
        printf "%-12s ${color}%-10s${PLAIN} %-9s %-15s %-15s\n" "$c" "$status" "$ssh_p" "$nat_info" "$pass"
    done
    read -p "按回车返回..." d
}

uninstall_script_env() {
    clear
    echo -e "${RED}警告: 此操作将删除所有数据!${PLAIN}"
    read -p "输入 yes 确认卸载: " confirm
    if [ "$confirm" == "yes" ]; then
        lxc list --format csv -c n | xargs -I {} lxc delete {} --force
        if command -v apt-get >/dev/null 2>&1; then apt-get purge lxd lxd-client -y; fi
        rm -rf /var/lib/lxd /var/log/lxd
        echo "清理完成。"
    fi
    read -p "回车..." d
}

start_wizard() {
    clear
    echo -e "${GREEN}创建向导 (安全加固)${PLAIN}"
    
    # 增加输入校验
    while true; do
        read -p "1. 基础名称 (如 test): " basename; basename=${basename:-test}
        validate_name "$basename" && break
    done
    
    while true; do
        read -p "2. 创建数量 (如 1): " count; count=${count:-1}
        validate_int "$count" && break
    done
    
    while true; do
        read -p "3. CPU核数 (如 0.5): " cpu; cpu=${cpu:-1}
        validate_float "$cpu" && break
    done
    
    while true; do
        read -p "4. 内存MB [256]: " memory; memory=${memory:-256}
        validate_int "$memory" && break
    done
    
    read -p "5. 硬盘GB [2]: " disk; disk=${disk:-2}

    echo -e "\n=== 操作系统 ==="
    echo " 1) Debian 12    2) Debian 11"
    echo " 3) Ubuntu 22.04 4) Ubuntu 20.04"
    echo " 5) CentOS 7     6) CentOS 9 (Stream)  7) Rocky 9"
    echo " 8) Arch Linux   9) Kali Linux"
    echo "10) Windows 11  11) Custom"

    read -p "选择: " os_c
    is_vm=false
    case $os_c in
        1) a="debian"; b="12" ;; 2) a="debian"; b="11" ;;
        3) a="ubuntu"; b="22.04" ;; 4) a="ubuntu"; b="20.04" ;;
        5) a="centos"; b="7" ;; 6) a="centos"; b="9-Stream" ;; 7) a="rockylinux"; b="9" ;;
        8) a="archlinux"; b="current" ;; 9) a="kali"; b="current" ;;
        10) a="win11"; b=""; is_vm=true ;;
        11) read -p "镜像名: " sys; a="custom"; b="$sys" ;;
        *) a="debian"; b="12" ;;
    esac

    mirror_choice="auto"
    if [ "$is_vm" == false ]; then
        echo -e "\n镜像源: [1]自动 [2]国内 [3]国外"
        read -p "选择 [1]: " m; [[ "$m" == "2" ]] && mirror_choice="cn"; [[ "$m" == "3" ]] && mirror_choice="global"
    fi

    echo -e "\n端口 (自动递增):"
    read -p "起始 SSH [20001]: " sshn_start; sshn_start=${sshn_start:-20001}
    read -p "起始 NAT [30000] (0禁用): " nat_start; nat_start=${nat_start:-30000}
    if [ "$nat_start" != "0" ]; then
        read -p "结束 NAT [30025]: " nat_end; nat_end=${nat_end:-30025}
    else nat_end=0; fi
    
    read -p "限速 MB/s [10]: " in_mb; in_mb=${in_mb:-10}
    in=$in_mb
    
    check_cdn_file
    is_rebuild="false"
    run_batch_creation
}

main_menu() {
    while true; do
        clear
        echo "=================================================="
        echo -e "      ${GREEN}LXD 终极管理 (Security Hardened)${PLAIN}"
        echo "=================================================="
        echo -e " 1. ${SKYBLUE}创建实例${PLAIN} (批量/单体)"
        echo -e " 2. ${SKYBLUE}查看列表${PLAIN}"
        echo -e " 3. ${GREEN}单机管理${PLAIN} (开关/重装/重名)"
        echo "--------------------------------------------------"
        echo -e " 4. 批量开关"
        echo -e " 5. 宿主Swap"
        echo -e " 6. BBR 加速"
        echo -e " 7. ${RED}环境卸载${PLAIN}"
        echo "--------------------------------------------------"
        echo -e " 0. 退出"
        read -p "请选择: " choice
        case $choice in
            1) start_wizard ;; 2) view_instances ;; 3) manage_single_instance ;;
            4) manage_all_menu ;; 5) add_host_swap ;; 6) enable_bbr ;; 7) uninstall_script_env ;;
            0) exit 0 ;;
        esac
    done
}

main() { init_env; check_lxd_env; detect_ip_info; check_cdn_file; main_menu; }
main "$@"
