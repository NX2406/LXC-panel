#!/usr/bin/env bash
set -euo pipefail

APP_DIR="/opt/lxd-panel"
DATA_DIR="${APP_DIR}/data"
LOG_DIR="/var/log/lxd-panel"
PY_VENV="${APP_DIR}/.venv"

say()  { echo -e "\033[1;36m[*]\033[0m $*"; }
warn() { echo -e "\033[1;33m[!]\033[0m $*"; }
err()  { echo -e "\033[1;31m[âœ—]\033[0m $*"; }

need_root(){ [[ $EUID -eq 0 ]] || { err "è¯·ç”¨ sudo/root è¿è¡Œ"; exit 1; }; }

ask(){ local p="$1" d="$2" v; read -r -p "${p}ï¼ˆé»˜è®¤ ${d}ï¼‰: " v; echo "${v:-$d}"; }
ask_yn(){ local p="$1" d="$2" v; read -r -p "${p} (y/nï¼Œé»˜è®¤ ${d}): " v; v="${v:-$d}"; v="$(echo "$v"|tr '[:upper:]' '[:lower:]')"; [[ "$v" == "y" || "$v" == "n" ]] && echo "$v" || echo "$d"; }
norm_path(){ local p="${1:-/}"; [[ "$p" == "/" ]] && { echo "/"; return; }; echo "/$(echo "$p"|sed 's#^/*##; s#/*$##')"; }

need_root

say "Panel ä¸€é”®éƒ¨ç½²ï¼ˆå…ˆç™»å½• -> å†é…å¯¹èŠ‚ç‚¹ -> å†åˆ›å»ºå®¹å™¨ï¼‰"
PANEL_PORT="$(ask "1) é¢æ¿å¯¹å¤–ç«¯å£ï¼ˆNginx listenï¼‰" "80")"
BACKEND_PORT="$(ask "2) é¢æ¿åç«¯ç«¯å£ï¼ˆuvicornï¼‰" "8089")"
BASE_PATH="$(norm_path "$(ask "3) é¢æ¿è®¿é—®è·¯å¾„ï¼ˆ/ æˆ– /panelï¼‰" "/")")"

CUSTOM_ADMIN="$(ask_yn "4) admin è´¦å·å¯†ç æ˜¯å¦è‡ªå®šä¹‰ï¼Ÿ" "n")"
ADMIN_USER="admin"
ADMIN_PASS="ChangeMeNow!"
if [[ "$CUSTOM_ADMIN" == "y" ]]; then
  ADMIN_USER="$(ask "   - admin ç”¨æˆ·å" "admin")"
  read -r -p "   - admin å¯†ç ï¼ˆç•™ç©ºåˆ™ç”¨é»˜è®¤ï¼‰: " t
  [[ -n "$t" ]] && ADMIN_PASS="$t"
fi

say "å®‰è£…ä¾èµ–..."
apt-get update -y
apt-get install -y nginx python3 python3-venv python3-pip openssl curl jq

say "åˆ›å»ºç›®å½•..."
mkdir -p "${APP_DIR}" "${DATA_DIR}" "${LOG_DIR}"

say "å†™å…¥åç«¯ app.py..."
cat > "${APP_DIR}/app.py" <<'PY'
import os, re, time, sqlite3, json
from typing import Optional, List, Dict, Any
import httpx
from fastapi import FastAPI, HTTPException, Request, Depends
from fastapi.middleware.cors import CORSMiddleware
from jose import jwt, JWTError
from passlib.context import CryptContext
from pydantic import BaseModel, Field

APP_NAME = "LXD-Panel"
DB_PATH = os.environ.get("LXD_PANEL_DB", "/opt/lxd-panel/data/panel.db")
JWT_SECRET = os.environ.get("LXD_PANEL_JWT_SECRET", "PLEASE_CHANGE_ME")
SEED_ADMIN_USER = os.environ.get("LXD_PANEL_ADMIN_USER", "admin")
SEED_ADMIN_PASS = os.environ.get("LXD_PANEL_ADMIN_PASS", "ChangeMeNow!")
JWT_ALG = "HS256"
TOKEN_TTL = 12 * 3600

pwd_ctx = CryptContext(schemes=["bcrypt"], deprecated="auto")
NAME_RE = re.compile(r"^[a-zA-Z0-9][a-zA-Z0-9\-]{1,30}$")

ALLOWED_IMAGES = [
    "images:ubuntu/22.04",
    "images:ubuntu/24.04",
    "images:debian/12",
]

DEFAULT_PORT_START = 20000
DEFAULT_PORT_END   = 40000

def db():
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    conn.execute("PRAGMA journal_mode=WAL;")
    conn.execute("PRAGMA synchronous=NORMAL;")
    return conn

def init_db():
    c = db()
    cur = c.cursor()
    cur.execute("""
    CREATE TABLE IF NOT EXISTS users(
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      username TEXT UNIQUE NOT NULL,
      password_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'user',
      created_at INTEGER NOT NULL
    );
    """)
    cur.execute("""
    CREATE TABLE IF NOT EXISTS nodes(
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      base_url TEXT NOT NULL,
      panel_key TEXT NOT NULL,
      ca_pem TEXT NOT NULL,
      client_cert_pem TEXT NOT NULL,
      client_key_pem TEXT NOT NULL,
      port_start INTEGER NOT NULL,
      port_end INTEGER NOT NULL,
      created_at INTEGER NOT NULL
    );
    """)
    cur.execute("""
    CREATE TABLE IF NOT EXISTS port_alloc(
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      node_id INTEGER NOT NULL,
      host_port INTEGER NOT NULL,
      user_id INTEGER NOT NULL,
      container_name TEXT NOT NULL,
      proto TEXT NOT NULL,
      inside_port INTEGER NOT NULL,
      created_at INTEGER NOT NULL,
      UNIQUE(node_id, host_port)
    );
    """)
    c.commit()

    cur.execute("SELECT id FROM users WHERE role='admin' LIMIT 1")
    if not cur.fetchone():
        cur.execute(
            "INSERT INTO users(username,password_hash,role,created_at) VALUES(?,?,?,?)",
            (SEED_ADMIN_USER, pwd_ctx.hash(SEED_ADMIN_PASS), "admin", int(time.time()))
        )
        c.commit()
    c.close()

def make_token(user: Dict[str, Any]) -> str:
    payload = {"sub": user["username"], "role": user["role"], "uid": user["id"], "exp": int(time.time()) + TOKEN_TTL}
    return jwt.encode(payload, JWT_SECRET, algorithm=JWT_ALG)

def parse_token(token: str) -> Dict[str, Any]:
    try:
        return jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALG])
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")

def current_user(req: Request) -> Dict[str, Any]:
    auth = req.headers.get("Authorization", "")
    if not auth.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Missing token")
    return parse_token(auth.split(" ", 1)[1].strip())

def require_admin(user=Depends(current_user)):
    if user.get("role") != "admin":
        raise HTTPException(status_code=403, detail="Admin only")
    return user

def ensure_short_name(s: str):
    if not NAME_RE.match(s):
        raise HTTPException(status_code=400, detail="Invalid name. Use letters/numbers/dash, 2-31 chars.")

def user_prefix(user: Dict[str, Any]) -> str:
    return f"u_{user['uid']}_"

def full_name(user: Dict[str, Any], short: str) -> str:
    return user_prefix(user) + short

def get_node(node_id: int) -> sqlite3.Row:
    c = db(); cur = c.cursor()
    cur.execute("SELECT * FROM nodes WHERE id=?", (node_id,))
    r = cur.fetchone()
    c.close()
    if not r: raise HTTPException(404, "node not found")
    return r

def cert_cache_dir() -> str:
    p = os.environ.get("LXD_PANEL_CERT_CACHE", "/opt/lxd-panel/cert-cache")
    os.makedirs(p, exist_ok=True)
    return p

def write_node_certs(node: sqlite3.Row) -> Dict[str, str]:
    d = cert_cache_dir()
    ca = os.path.join(d, f"node{node['id']}.ca.pem")
    crt= os.path.join(d, f"node{node['id']}.client.crt.pem")
    key= os.path.join(d, f"node{node['id']}.client.key.pem")
    def w(path, content, mode):
        old=None
        if os.path.exists(path):
            with open(path,"r",encoding="utf-8") as f: old=f.read()
        if old != content:
            with open(path,"w",encoding="utf-8") as f: f.write(content)
            os.chmod(path, mode)
    w(ca, node["ca_pem"], 0o644)
    w(crt,node["client_cert_pem"],0o644)
    w(key,node["client_key_pem"],0o600)
    return {"ca":ca, "crt":crt, "key":key}

async def agent_call(node: sqlite3.Row, method: str, path: str, json_body: Optional[dict]=None) -> dict:
    url = node["base_url"].rstrip("/") + path
    files = write_node_certs(node)
    headers = {"X-Panel-Key": node["panel_key"]}
    timeout = httpx.Timeout(8.0, read=60.0)
    async with httpx.AsyncClient(timeout=timeout, verify=files["ca"], cert=(files["crt"], files["key"])) as client:
        r = await client.request(method, url, headers=headers, json=json_body)
        try:
            data = r.json()
        except Exception:
            data = {"detail": r.text}
        if r.status_code >= 400:
            raise HTTPException(status_code=r.status_code, detail=data.get("detail", data))
        return data

def alloc_port(node_id: int, user_id: int, container_name: str, proto: str, inside_port: int) -> int:
    # æŒ‰éœ€åˆ†é…ï¼šä» node çš„ [port_start, port_end] æ‰¾ç©ºé—²ç«¯å£
    c = db(); cur = c.cursor()
    cur.execute("SELECT port_start, port_end FROM nodes WHERE id=?", (node_id,))
    row = cur.fetchone()
    if not row:
        c.close()
        raise HTTPException(404, "node not found")
    ps, pe = int(row["port_start"]), int(row["port_end"])
    cur.execute("SELECT host_port FROM port_alloc WHERE node_id=? ORDER BY host_port ASC", (node_id,))
    used = set([int(r[0]) for r in cur.fetchall()])
    for p in range(ps, pe+1):
        if p not in used:
            cur.execute(
                "INSERT INTO port_alloc(node_id,host_port,user_id,container_name,proto,inside_port,created_at) VALUES(?,?,?,?,?,?,?)",
                (node_id, p, user_id, container_name, proto, inside_port, int(time.time()))
            )
            c.commit()
            c.close()
            return p
    c.close()
    raise HTTPException(409, "Port pool exhausted")

class LoginReq(BaseModel):
    username: str
    password: str

class PairNodeReq(BaseModel):
    agent_url: str = Field(..., description="https://<agent_ip_or_domain>:443")
    pair_token: str = Field(..., description="token printed by agent installer")
    node_name: Optional[str] = None
    port_start: int = DEFAULT_PORT_START
    port_end: int = DEFAULT_PORT_END

class CreateContainerReq(BaseModel):
    node_id: int
    name: str
    image: str
    cpu: str = "2"             # e.g. "2" or "0,1"
    memory_mb: int = 1024
    disk_gb: int = 10
    net_ingress_mbit: Optional[int] = None
    net_egress_mbit: Optional[int] = None
    expose: List[Dict[str, Any]] = []  # [{"proto":"tcp","inside_port":80}, ...]

app = FastAPI(title=APP_NAME)
app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_credentials=True, allow_methods=["*"], allow_headers=["*"])

@app.on_event("startup")
def _startup():
    init_db()

@app.get("/api/health")
def health():
    return {"ok": True, "app": APP_NAME, "ts": int(time.time())}

@app.post("/api/login")
def login(body: LoginReq):
    c = db(); cur = c.cursor()
    cur.execute("SELECT * FROM users WHERE username=?", (body.username,))
    row = cur.fetchone()
    c.close()
    if not row or not pwd_ctx.verify(body.password, row["password_hash"]):
        raise HTTPException(401, "Bad credentials")
    token = make_token({"id": row["id"], "username": row["username"], "role": row["role"]})
    return {"token": token, "role": row["role"], "username": row["username"]}

@app.get("/api/me")
def me(user=Depends(current_user)):
    return {"username": user["sub"], "role": user["role"], "uid": user["uid"]}

@app.get("/api/images")
def images(user=Depends(current_user)):
    return {"items": ALLOWED_IMAGES}

@app.post("/api/admin/nodes/pair")
async def pair_node(body: PairNodeReq, admin=Depends(require_admin)):
    agent_url = body.agent_url.strip().rstrip("/")
    if not agent_url.startswith("https://"):
        raise HTTPException(400, "agent_url must start with https://")
    if body.port_start < 1024 or body.port_end <= body.port_start:
        raise HTTPException(400, "bad port range")

    # å…ˆç”¨ pair_token å‘ agent enrollï¼ˆæ— éœ€æœ¬åœ° certï¼‰
    timeout = httpx.Timeout(8.0, read=60.0)
    async with httpx.AsyncClient(timeout=timeout, verify=False) as client:
        r = await client.post(agent_url + "/agent/enroll", json={"pair_token": body.pair_token.strip()})
        try:
            j = r.json()
        except Exception:
            j = {"detail": r.text}
        if r.status_code >= 400:
            raise HTTPException(r.status_code, j.get("detail", j))

    # agent è¿”å›ï¼šca_pem / client_cert_pem / client_key_pem / panel_key / node_name
    node_name = body.node_name or j.get("node_name") or agent_url
    ca_pem = j.get("ca_pem","")
    client_cert_pem = j.get("client_cert_pem","")
    client_key_pem = j.get("client_key_pem","")
    panel_key = j.get("panel_key","")
    if not all([ca_pem, client_cert_pem, client_key_pem, panel_key]):
        raise HTTPException(400, "agent enroll response incomplete")

    c = db(); cur = c.cursor()
    cur.execute(
        "INSERT INTO nodes(name,base_url,panel_key,ca_pem,client_cert_pem,client_key_pem,port_start,port_end,created_at) VALUES(?,?,?,?,?,?,?,?,?)",
        (node_name, agent_url, panel_key, ca_pem, client_cert_pem, client_key_pem, int(body.port_start), int(body.port_end), int(time.time()))
    )
    c.commit()
    node_id = cur.lastrowid
    c.close()

    # ç”¨ mTLS + key åšå¥åº·æ£€æŸ¥ï¼ˆéªŒè¯é“¾è·¯ï¼‰
    node = get_node(node_id)
    await agent_call(node, "GET", "/agent/health")

    return {"ok": True, "node_id": node_id, "name": node_name}

@app.get("/api/nodes")
def list_nodes(user=Depends(current_user)):
    c = db(); cur = c.cursor()
    cur.execute("SELECT id,name,base_url,port_start,port_end,created_at FROM nodes ORDER BY id DESC")
    rows = [dict(r) for r in cur.fetchall()]
    c.close()
    return {"items": rows}

@app.get("/api/containers")
async def list_containers(node_id: int, user=Depends(current_user)):
    node = get_node(node_id)
    data = await agent_call(node, "GET", "/agent/containers")
    items = data.get("items", [])
    if user.get("role") == "admin":
        return {"items": items}
    pref = user_prefix(user)
    return {"items": [x for x in items if (x.get("name","").startswith(pref))]}

@app.post("/api/containers")
async def create_container(body: CreateContainerReq, user=Depends(current_user)):
    ensure_short_name(body.name)
    if body.image not in ALLOWED_IMAGES and user.get("role") != "admin":
        raise HTTPException(400, f"image not allowed. allowed={ALLOWED_IMAGES}")

    node = get_node(body.node_id)
    cname = full_name(user, body.name)

    # ç«¯å£æŒ‰éœ€åˆ†é…
    mappings = []
    for x in body.expose:
        proto = str(x.get("proto","tcp")).lower()
        inside = int(x.get("inside_port", 0))
        if proto not in ("tcp","udp") or inside <= 0 or inside > 65535:
            raise HTTPException(400, "bad expose item")
        host_port = alloc_port(body.node_id, int(user["uid"]), cname, proto, inside)
        mappings.append({"proto": proto, "host_port": host_port, "inside_port": inside})

    payload = {
        "name": cname,
        "image": body.image,
        "cpu": body.cpu,
        "memory_mb": body.memory_mb,
        "disk_gb": body.disk_gb,
        "net_ingress_mbit": body.net_ingress_mbit,
        "net_egress_mbit": body.net_egress_mbit,
        "ports": mappings
    }
    data = await agent_call(node, "POST", "/agent/containers", json_body=payload)
    return {"ok": True, "name": data.get("name", cname), "assigned_ports": data.get("assigned_ports", mappings)}
PY

say "å†™å…¥å‰ç«¯ index.html..."
cat > "${APP_DIR}/index.html" <<'HTML'
<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LXD Panel</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto;margin:0;background:#0b0f17;color:#e6edf3}
  .wrap{max-width:1100px;margin:0 auto;padding:22px}
  .card{background:#111827;border:1px solid #1f2937;border-radius:14px;padding:16px;margin:14px 0}
  input,select,button,textarea{background:#0b1220;border:1px solid #233047;color:#e6edf3;padding:10px 12px;border-radius:10px}
  textarea{min-height:100px;width:100%}
  button{cursor:pointer}
  button.primary{background:#1d4ed8;border-color:#1d4ed8}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .grow{flex:1}
  .muted{color:#9ca3af}
  table{width:100%;border-collapse:collapse;font-size:14px}
  th,td{border-bottom:1px solid #22304a;padding:10px 8px;text-align:left}
  pre{white-space:pre-wrap;background:#0b1220;border:1px solid #233047;padding:12px;border-radius:10px}
</style>
</head>
<body>
<div class="wrap">
  <div class="row" style="justify-content:space-between">
    <div>
      <div style="font-weight:800">ğŸ›¡ï¸ LXD Panel <span class="muted" style="font-size:12px">å…ˆç™»å½•â†’å†é…å¯¹â†’å†åˆ›å»º</span></div>
      <div class="muted" id="who">æœªç™»å½•</div>
      <div class="muted" id="apiStatus" style="font-size:12px"></div>
    </div>
    <button onclick="logout()">é€€å‡º</button>
  </div>

  <div class="card" id="loginCard">
    <h3>ç™»å½•</h3>
    <div class="row">
      <input id="u" value="admin" placeholder="ç”¨æˆ·å"/>
      <input id="p" value="ChangeMeNow!" type="password" placeholder="å¯†ç "/>
      <button class="primary" onclick="login()">ç™»å½•</button>
    </div>
    <div class="muted" id="loginMsg"></div>
  </div>

  <div class="card" id="pairCard" style="display:none">
    <h3>èŠ‚ç‚¹é…å¯¹ï¼ˆadminï¼‰</h3>
    <div class="muted">åœ¨è¢«æ§æœºå®‰è£… Agent åï¼Œä¼šè¾“å‡º pair_tokenã€‚è¿™é‡Œè¾“å…¥ agent_url + pair_token å®Œæˆç»‘å®šã€‚</div>
    <div class="row">
      <input id="agentUrl" class="grow" placeholder="https://<agent_ip_or_domain>:443"/>
      <input id="pairToken" class="grow" placeholder="pair_token"/>
      <input id="pstart" value="20000" style="width:120px" placeholder="port_start"/>
      <input id="pend" value="40000" style="width:120px" placeholder="port_end"/>
      <button class="primary" onclick="pair()">é…å¯¹</button>
    </div>
    <div class="muted" id="pairMsg"></div>
  </div>

  <div class="card" id="nodeCard" style="display:none">
    <div class="row" style="justify-content:space-between">
      <h3 style="margin:0">èŠ‚ç‚¹</h3>
      <button onclick="loadNodes()">åˆ·æ–°</button>
    </div>
    <div class="row">
      <select id="nodeSel" onchange="loadContainers()"></select>
      <span class="muted">ç«¯å£æ± æŒ‰éœ€åˆ†é…ï¼Œåˆ›å»ºå®¹å™¨æ—¶è‡ªåŠ¨ä¸‹å‘ LXD proxy æ˜ å°„ã€‚</span>
    </div>
  </div>

  <div class="card" id="createCard" style="display:none">
    <h3>åˆ›å»ºå®¹å™¨</h3>
    <div class="row">
      <input id="cname" placeholder="çŸ­åï¼šweb-01"/>
      <select id="image"></select>
      <input id="cpu" value="2" style="width:160px" placeholder='CPU: "2" æˆ– "0,1"'/>
      <input id="mem" type="number" value="1024" style="width:140px" placeholder="å†…å­˜MB"/>
      <input id="disk" type="number" value="10" style="width:140px" placeholder="ç£ç›˜GB"/>
      <input id="ing" type="number" placeholder="Ingress Mbit(å¯ç©º)" style="width:170px"/>
      <input id="eg"  type="number" placeholder="Egress Mbit(å¯ç©º)" style="width:170px"/>
    </div>
    <div style="margin-top:10px" class="muted">ç«¯å£æ˜ å°„ï¼ˆæŒ‰éœ€åˆ†é…å®¿ä¸»æœºç«¯å£ï¼‰ï¼šæ¯è¡Œä¸€ä¸ªï¼Œå¦‚ï¼štcp 80</div>
    <textarea id="ports" placeholder="ä¾‹ï¼š&#10;tcp 80&#10;tcp 22"></textarea>
    <div class="row">
      <button class="primary" onclick="create()">åˆ›å»º</button>
      <span class="muted" id="createMsg"></span>
    </div>
    <pre id="createOut" class="muted"></pre>
  </div>

  <div class="card" id="listCard" style="display:none">
    <div class="row" style="justify-content:space-between">
      <h3 style="margin:0">å®¹å™¨åˆ—è¡¨</h3>
      <button onclick="loadContainers()">åˆ·æ–°</button>
    </div>
    <table>
      <thead><tr><th>åç§°</th><th>çŠ¶æ€</th><th>IPv4</th></tr></thead>
      <tbody id="tbody"></tbody>
    </table>
  </div>
</div>

<script>
const BASE="__BASE_PATH__";
const API=(BASE==="/"?"":BASE)+"/api";
let token=localStorage.getItem("token")||"";
let me=null;

function h(){ return token?{"Authorization":"Bearer "+token}:{}; }
function msg(id,t){ document.getElementById(id).innerText=t||""; }

async function fetchT(url,opt={},ms=12000){
  const c=new AbortController(); const id=setTimeout(()=>c.abort(),ms);
  try{ const r=await fetch(url,{...opt,signal:c.signal}); clearTimeout(id); return r; }
  catch(e){ clearTimeout(id); throw e; }
}

async function probe(){
  try{
    const r=await fetchT(API+"/health",{},4000);
    msg("apiStatus", r.ok ? "APIï¼šåœ¨çº¿ âœ…" : "APIï¼šå¼‚å¸¸ âŒ");
  }catch(e){ msg("apiStatus","APIï¼šä¸å¯ç”¨ âŒï¼ˆæ£€æŸ¥Nginx/åç«¯/è·¯å¾„å‰ç¼€ï¼‰"); }
}

async function login(){
  msg("loginMsg","ç™»å½•ä¸­...");
  try{
    const r=await fetchT(API+"/login",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({username:u.value.trim(),password:p.value})},12000);
    const j=await r.json().catch(()=>({}));
    if(!r.ok){ msg("loginMsg", j.detail||("ç™»å½•å¤±è´¥ HTTP "+r.status)); return; }
    token=j.token; localStorage.setItem("token",token);
    await boot();
  }catch(e){ msg("loginMsg","ç™»å½•è¶…æ—¶/ç½‘ç»œé”™è¯¯"); }
}

function logout(){ token=""; localStorage.removeItem("token"); location.reload(); }

async function boot(){
  const r=await fetchT(API+"/me",{headers:h()},8000);
  if(!r.ok){ logout(); return; }
  me=await r.json();
  who.innerText=`å·²ç™»å½•ï¼š${me.username}ï¼ˆ${me.role}ï¼‰`;
  loginCard.style.display="none";
  nodeCard.style.display="";
  createCard.style.display="";
  listCard.style.display="";
  pairCard.style.display=(me.role==="admin")?"":"none";

  const ir=await fetchT(API+"/images",{headers:h()},8000);
  const ij=await ir.json();
  image.innerHTML="";
  (ij.items||[]).forEach(x=>{const o=document.createElement("option");o.value=x;o.textContent=x;image.appendChild(o);});
  await loadNodes();
}

async function pair(){
  msg("pairMsg","é…å¯¹ä¸­...");
  try{
    const body={agent_url:agentUrl.value.trim(),pair_token:pairToken.value.trim(),port_start:parseInt(pstart.value||"20000",10),port_end:parseInt(pend.value||"40000",10)};
    const r=await fetchT(API+"/admin/nodes/pair",{method:"POST",headers:{"Content-Type":"application/json",...h()},body:JSON.stringify(body)},20000);
    const j=await r.json().catch(()=>({}));
    if(!r.ok){ msg("pairMsg", j.detail||("é…å¯¹å¤±è´¥ HTTP "+r.status)); return; }
    msg("pairMsg","é…å¯¹æˆåŠŸ âœ… node_id="+j.node_id);
    await loadNodes();
  }catch(e){ msg("pairMsg","é…å¯¹è¶…æ—¶/ç½‘ç»œé”™è¯¯ï¼ˆæ£€æŸ¥agent_urlæ˜¯å¦å¯è¾¾ã€443æ˜¯å¦æ”¾è¡Œï¼‰"); }
}

async function loadNodes(){
  const r=await fetchT(API+"/nodes",{headers:h()},8000);
  const j=await r.json();
  nodeSel.innerHTML="";
  (j.items||[]).forEach(n=>{const o=document.createElement("option");o.value=n.id;o.textContent=`#${n.id} ${n.name} (${n.base_url})`;nodeSel.appendChild(o);});
  if((j.items||[]).length>0) await loadContainers();
}

async function create(){
  const nid=parseInt(nodeSel.value||"0",10);
  if(!nid){ msg("createMsg","è¯·å…ˆé…å¯¹å¹¶é€‰æ‹©èŠ‚ç‚¹"); return; }
  msg("createMsg","åˆ›å»ºä¸­...");
  const lines=(ports.value||"").split("\n").map(s=>s.trim()).filter(Boolean);
  const expose=[];
  for(const ln of lines){
    const a=ln.split(/\s+/);
    if(a.length!==2) continue;
    expose.push({proto:a[0].toLowerCase(),inside_port:parseInt(a[1],10)});
  }
  const body={
    node_id:nid,name:cname.value.trim(),image:image.value,
    cpu:cpu.value.trim()||"2",memory_mb:parseInt(mem.value||"1024",10),disk_gb:parseInt(disk.value||"10",10),
    net_ingress_mbit: ing.value.trim()?parseInt(ing.value.trim(),10):null,
    net_egress_mbit:  eg.value.trim()?parseInt(eg.value.trim(),10):null,
    expose
  };
  try{
    const r=await fetchT(API+"/containers",{method:"POST",headers:{"Content-Type":"application/json",...h()},body:JSON.stringify(body)},30000);
    const j=await r.json().catch(()=>({}));
    if(!r.ok){ msg("createMsg", j.detail||("å¤±è´¥ HTTP "+r.status)); return; }
    msg("createMsg","åˆ›å»ºæˆåŠŸ âœ…");
    createOut.innerText=JSON.stringify(j,null,2);
    await loadContainers();
  }catch(e){ msg("createMsg","åˆ›å»ºè¶…æ—¶/ç½‘ç»œé”™è¯¯ï¼ˆé¦–æ¬¡æ‹‰é•œåƒå¯èƒ½æ…¢ï¼‰"); }
}

async function loadContainers(){
  const nid=parseInt(nodeSel.value||"0",10);
  if(!nid) return;
  const r=await fetchT(API+`/containers?node_id=${nid}`,{headers:h()},15000);
  const j=await r.json();
  tbody.innerHTML="";
  (j.items||[]).forEach(it=>{
    const tr=document.createElement("tr");
    tr.innerHTML=`<td>${it.name||"-"}</td><td>${it.status||"-"}</td><td>${it.ipv4||"-"}</td>`;
    tbody.appendChild(tr);
  });
}

probe();
if(token) boot();
</script>
</body>
</html>
HTML

say "æ³¨å…¥ BASE_PATH..."
sed -i "s|__BASE_PATH__|${BASE_PATH}|g" "${APP_DIR}/index.html"

say "åˆ›å»º venv å¹¶å®‰è£…ä¾èµ–..."
python3 -m venv "${PY_VENV}"
"${PY_VENV}/bin/pip" install --upgrade pip >/dev/null
"${PY_VENV}/bin/pip" install fastapi==0.115.0 uvicorn[standard]==0.30.6 python-jose==3.3.0 passlib[bcrypt]==1.7.4 pydantic==2.8.2 httpx==0.27.2 >/dev/null

say "å†™å…¥ systemd..."
JWT_SECRET="$(openssl rand -hex 32)"
cat > /etc/systemd/system/lxd-panel.service <<EOF
[Unit]
Description=LXD Panel Backend
After=network.target

[Service]
Type=simple
WorkingDirectory=${APP_DIR}
Environment="LXD_PANEL_DB=${DATA_DIR}/panel.db"
Environment="LXD_PANEL_CERT_CACHE=${APP_DIR}/cert-cache"
Environment="LXD_PANEL_JWT_SECRET=${JWT_SECRET}"
Environment="LXD_PANEL_ADMIN_USER=${ADMIN_USER}"
Environment="LXD_PANEL_ADMIN_PASS=${ADMIN_PASS}"
ExecStart=${PY_VENV}/bin/uvicorn app:app --host 127.0.0.1 --port ${BACKEND_PORT}
Restart=always
RestartSec=2
StandardOutput=append:${LOG_DIR}/panel.log
StandardError=append:${LOG_DIR}/panel.err

[Install]
WantedBy=multi-user.target
EOF
systemctl daemon-reload
systemctl enable --now lxd-panel.service

say "é…ç½® Nginxï¼ˆè§£å†³ 502ï¼šç«¯å£å¼ºä¸€è‡´ï¼‰..."
NGINX_SITE="/etc/nginx/sites-available/lxd-panel"
if [[ "${BASE_PATH}" == "/" ]]; then
cat > "${NGINX_SITE}" <<EOF
server {
  listen ${PANEL_PORT} default_server;
  listen [::]:${PANEL_PORT} default_server;
  server_name _;

  root ${APP_DIR};
  index index.html;

  location / { try_files \$uri \$uri/ /index.html; }

  location /api/ {
    proxy_pass http://127.0.0.1:${BACKEND_PORT}/api/;
    proxy_http_version 1.1;
    proxy_set_header Host \$host;
    proxy_set_header X-Real-IP \$remote_addr;
    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
  }
}
EOF
else
cat > "${NGINX_SITE}" <<EOF
server {
  listen ${PANEL_PORT} default_server;
  listen [::]:${PANEL_PORT} default_server;
  server_name _;

  location ${BASE_PATH}/ {
    alias ${APP_DIR}/;
    try_files \$uri \$uri/ ${BASE_PATH}/index.html;
  }

  location ${BASE_PATH}/api/ {
    proxy_pass http://127.0.0.1:${BACKEND_PORT}/api/;
    proxy_http_version 1.1;
    proxy_set_header Host \$host;
    proxy_set_header X-Real-IP \$remote_addr;
    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
  }
}
EOF
fi

rm -f /etc/nginx/sites-enabled/default || true
ln -sf /etc/nginx/sites-available/lxd-panel /etc/nginx/sites-enabled/lxd-panel
nginx -t
systemctl enable --now nginx
systemctl restart nginx

say "æœ¬åœ°å¥åº·æ£€æŸ¥..."
curl -fsS "http://127.0.0.1:${BACKEND_PORT}/api/health" >/dev/null && say "åç«¯ OK" || warn "åç«¯å¼‚å¸¸ï¼šjournalctl -u lxd-panel -n 200 --no-pager"

echo "------------------------------------------------------------"
echo "âœ… Panel å®Œæˆï¼ˆå…ˆç™»å½•å†é…å¯¹èŠ‚ç‚¹ï¼‰"
echo "è®¿é—®ï¼š http://<é¢æ¿IP>:${PANEL_PORT}${BASE_PATH}/"
echo "Adminï¼š${ADMIN_USER}"
echo "Pass ï¼š${ADMIN_PASS}"
echo "æ—¥å¿—ï¼š journalctl -u lxd-panel -n 200 --no-pager"
echo "------------------------------------------------------------"
