#!/usr/bin/env bash
# 纯交互版 LXD 管理脚本 (防报错增强版)
# 功能：环境自检 / 自动初始化 / 错误熔断 / 交互菜单
# 2025.11.10 Fixed & Robust

# --- 颜色配置 ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
SKYBLUE='\033[0;36m'
PLAIN='\033[0m'
DIVIDER="${SKYBLUE}------------------------------------------------------${PLAIN}"

# --- 1. 环境检查与自修复 (新增) ---

check_root() {
    if [ "$(id -u)" != "0" ]; then
        echo -e "${RED}错误: 本脚本必须以 ROOT 身份运行!${PLAIN}"
        exit 1
    fi
}

check_lxd_env() {
    echo -e "${SKYBLUE}正在检查 LXD 环境状态...${PLAIN}"
    
    # 1. 检查命令是否存在
    if ! command -v lxc >/dev/null 2>&1; then
        echo -e "${YELLOW}检测到未安装 LXD，正在尝试自动安装...${PLAIN}"
        if command -v apt-get >/dev/null 2>&1; then
            apt-get update && apt-get install lxd -y
        elif command -v yum >/dev/null 2>&1; then
            yum install lxd -y
        elif command -v apk >/dev/null 2>&1; then
            apk add lxd
        else
            echo -e "${RED}无法自动安装 LXD，请手动安装后重试。${PLAIN}"
            exit 1
        fi
    fi

    # 2. 检查 LXD 是否初始化 (关键修复: 解决 Storage pool not found)
    # 尝试列出存储池，如果失败或为空，说明未初始化
    if ! lxc storage list >/dev/null 2>&1 || [ -z "$(lxc storage list --format csv)" ]; then
        echo -e "${YELLOW}LXD 尚未初始化，正在执行自动初始化 (lxd init --auto)...${PLAIN}"
        lxd init --auto
        if [ $? -ne 0 ]; then
            echo -e "${RED}LXD 初始化失败！请检查系统日志或手动执行 'lxd init'。${PLAIN}"
            exit 1
        fi
        echo -e "${GREEN}LXD 初始化完成。${PLAIN}"
    else
        echo -e "${GREEN}LXD 环境正常。${PLAIN}"
    fi
}

init_env() {
    check_root
    cd /root >/dev/null 2>&1
    
    # 清理残留的垃圾文件 (关键修复: 解决文件名 .1 冲突)
    echo -e "${SKYBLUE}清理临时文件...${PLAIN}"
    rm -rf lxd.tar.xz rootfs.squashfs *.zip *.zip.* ChangeMirrors.sh ssh_*.sh config.sh build_ipv6_network.sh
    
    if ! command -v jq >/dev/null 2>&1; then
        echo -e "${YELLOW}正在安装 jq 依赖...${PLAIN}"
        if command -v apt-get >/dev/null 2>&1; then
            apt-get update -y >/dev/null 2>&1 && apt-get install jq -y >/dev/null 2>&1
        elif command -v yum >/dev/null 2>&1; then
            yum install jq -y >/dev/null 2>&1
        elif command -v apk >/dev/null 2>&1; then
            apk add jq >/dev/null 2>&1
        fi
    fi
}

# --- 2. 基础工具函数 ---

detect_ip_info() {
    country_code=$(curl -m 5 -s https://ipapi.co/json | jq -r '.country_code' 2>/dev/null)
    if [[ -z "$country_code" || "$country_code" == "null" ]]; then
        country_code=$(curl -m 5 -s https://api.ip.sb/geoip | jq -r '.country_code' 2>/dev/null)
    fi
    [[ "$country_code" == "CN" ]] && CN=true || CN=false
}

check_cdn_file() {
    cdn_urls=("https://cdn0.spiritlhl.top/" "http://cdn1.spiritlhl.net/" "http://cdn2.spiritlhl.net/" "http://cdn3.spiritlhl.net/" "http://cdn4.spiritlhl.net/")
    local shuffled=($(shuf -e "${cdn_urls[@]}")) 
    for url in "${shuffled[@]}"; do
        if curl -4 -sL -k "${url}https://raw.githubusercontent.com/spiritLHLS/ecs/main/back/test" --max-time 6 | grep -q "success"; then
            export cdn_success_url="$url"
            return
        fi
    done
    export cdn_success_url=""
}

get_system_arch() {
    sysarch="$(uname -m)"
    case "${sysarch}" in
        "x86_64"|"amd64") sys_bit="x86_64" ;;
        "aarch64"|"armv8") sys_bit="aarch64" ;;
        *) sys_bit="x86_64" ;;
    esac
}

# --- 3. 核心创建逻辑 (增强错误处理) ---

process_image() {
    image_download_url=""
    fixed_system=false
    
    # 尝试自定义镜像
    if [[ "$sys_bit" == "x86_64" || "$sys_bit" == "arm64" ]]; then
        self_fixed_images=($(curl -slk -m 6 ${cdn_success_url}https://raw.githubusercontent.com/oneclickvirt/lxd_images/main/${sys_bit}_all_images.txt))
        for image_name in "${self_fixed_images[@]}"; do
             if [[ -n "$b" ]]; then
                if [[ "$image_name" == "${a}_${b}"* ]]; then use_fixed_image "$image_name"; break; fi
             else
                if [[ "$image_name" == "${a}"* ]]; then use_fixed_image "$image_name"; break; fi
             fi
        done
    else
        output=$(lxc image list images:${a}/${b})
    fi
    
    # 尝试官方镜像
    if [ -z "$image_download_url" ]; then
        local type_flag="container"; [ "$is_vm" == true ] && type_flag="virtual-machine"
        system=$(lxc image list images:${a}/${b} --format=json | jq -r --arg ARCHITECTURE "$sys_bit" --arg TYPE "$type_flag" '.[] | select(.type == $TYPE and .architecture == $ARCHITECTURE) | .aliases[0].name' | head -n 1)
        if [ -n "$system" ]; then echo -e "${GREEN}使用官方镜像: ${system}${PLAIN}"; fixed_system=false; fi
    fi
    
    # 尝试 Opsmaru 镜像
    if [ -z "$image_download_url" ] && [ -z "$system" ] && [ "$is_vm" == false ]; then
        system=$(lxc image list opsmaru:${a}/${b} --format=json | jq -r --arg ARCHITECTURE "$sys_bit" '.[] | select(.type == "container" and .architecture == $ARCHITECTURE) | .aliases[0].name' | head -n 1)
        if echo "$system" | grep -q "${a}"; then status_tuna=true; fixed_system=false; else echo -e "${RED}错误：找不到匹配的镜像资源。${PLAIN}"; exit 1; fi
    fi
}

use_fixed_image() {
    local image_name=$1; fixed_system=true
    image_download_url="https://github.com/oneclickvirt/lxd_images/releases/download/${a}/${image_name}"
    
    # 检查本地是否已存在该别名，存在则跳过下载
    if [[ $(lxc image alias list) != *"$image_name"* ]]; then
        echo -e "${SKYBLUE}正在下载镜像: ${image_name}...${PLAIN}"
        
        # 强制指定输出文件名，防止 wget 生成 .1 文件
        wget -O "lxd_image.zip" "${cdn_success_url}${image_download_url}"
        
        if [ ! -f "lxd_image.zip" ]; then
            echo -e "${RED}下载失败，请检查网络连接。${PLAIN}"
            exit 1
        fi
        
        chmod 777 "lxd_image.zip"
        unzip -o "lxd_image.zip" # -o 覆盖已存在文件
        rm -f "lxd_image.zip" # 及时清理
        
        if [ ! -f "lxd.tar.xz" ]; then
             # 有些压缩包结构可能不同，直接导入 zip 尝试
             echo -e "${YELLOW}未发现 lxd.tar.xz，尝试直接导入目录...${PLAIN}"
        fi
        
        lxc image import lxd.tar.xz rootfs.squashfs --alias "$image_name"
        rm -rf lxd.tar.xz rootfs.squashfs
    else
        echo -e "${GREEN}镜像已存在，跳过下载。${PLAIN}"
    fi
}

create_container() {
    echo -e "${SKYBLUE}正在创建实例: $name ...${PLAIN}"
    
    # 先清理同名旧实例
    if lxc info "$name" >/dev/null 2>&1; then
        echo -e "${YELLOW}发现同名实例，正在删除...${PLAIN}"
        lxc delete "$name" --force
    fi

    local args="-c limits.cpu=$cpu -c limits.memory=${memory}MiB -s default"
    [ "$is_vm" == true ] && args="--vm $args"
    
    # 执行创建命令
    if [ -n "$image_download_url" ]; then 
        lxc init "$image_name" "$name" $args
    elif [ "$status_tuna" = true ]; then 
        lxc init opsmaru:${system} "$name" $args
    else 
        lxc init images:${system} "$name" $args
    fi
    
    # --- 关键修复: 错误熔断 ---
    # 如果创建失败，直接退出，不执行后续配置，避免刷屏报错
    if [ $? -ne 0 ]; then
        echo -e "${RED}=========================================${PLAIN}"
        echo -e "${RED}严重错误: 实例创建失败!${PLAIN}"
        echo -e "${RED}这通常是因为:${PLAIN}"
        echo -e "${RED}1. 镜像文件损坏或不兼容${PLAIN}"
        echo -e "${RED}2. 存储池空间不足${PLAIN}"
        echo -e "${RED}3. 虚拟化不支持 (如在 OpenVZ 上运行)${PLAIN}"
        echo -e "${RED}脚本已停止运行，请解决上述问题后重试。${PLAIN}"
        echo -e "${RED}=========================================${PLAIN}"
        exit 1
    fi
}

configure_storage() {
    # 增加对存储池是否存在的检查
    if ! lxc storage show default >/dev/null 2>&1; then
        echo -e "${RED}错误: 默认存储池 'default' 不存在或损坏。${PLAIN}"
        exit 1
    fi

    local st="btrfs"; [ -f /usr/local/bin/lxd_storage_type ] && st=$(cat /usr/local/bin/lxd_storage_type)
    [[ $disk == *.* ]] && d_mb=$(echo "$disk * 1024" | bc | cut -d. -f1)MB || d_mb="${disk}GB"
    
    lxc storage create "$name" "$st" size="$d_mb" >/dev/null 2>&1
    lxc config device override "$name" root size="$d_mb"
    lxc config device set "$name" root limits.max "$d_mb"
}

configure_resources() {
    lxc config device set "$name" root limits.read 500MB
    lxc config device set "$name" root limits.write 500MB
    lxc config device set "$name" root limits.read 5000iops
    lxc config device set "$name" root limits.write 5000iops
    lxc config set "$name" limits.cpu.priority 0
    lxc config set "$name" limits.cpu.allowance 50%
    lxc config set "$name" security.nesting true
    if [ "$is_vm" == true ]; then lxc config set "$name" security.secureboot=false; else lxc config set "$name" limits.memory.swap true; fi
}

setup_system() {
    echo -e "${SKYBLUE}初始化系统...${PLAIN}"; ori=$(date | md5sum); passwd=${ori:2:9}
    lxc start "$name"; sleep 3
    if [ "$is_vm" == true ]; then return; fi
    if [ "$fixed_system" = false ]; then setup_mirrors; install_packages; fi
    setup_ssh; configure_ipv6
}

setup_mirrors() {
    [[ "$mirror_choice" == "off" || "$system" == *"win"* ]] && return
    local use_cn=false; [[ "$mirror_choice" == "cn" || ("$mirror_choice" == "auto" && "$CN" == true) ]] && use_cn=true
    if [ "$use_cn" == true ]; then
        lxc exec "$name" -- apt-get install curl -y --fix-missing >/dev/null 2>&1
        lxc exec "$name" -- yum install -y curl >/dev/null 2>&1
        lxc exec "$name" -- curl -lk https://gitee.com/SuperManito/LinuxMirrors/raw/main/ChangeMirrors.sh -o ChangeMirrors.sh
        lxc exec "$name" -- chmod 777 ChangeMirrors.sh
        lxc exec "$name" -- ./ChangeMirrors.sh --source mirrors.tuna.tsinghua.edu.cn --web-protocol http --intranet false --backup true --updata-software false --clean-cache false --ignore-backup-tips
        lxc exec "$name" -- rm -rf ChangeMirrors.sh
    else
        lxc exec "$name" -- apt-get update -y >/dev/null 2>&1 || lxc exec "$name" -- yum makecache >/dev/null 2>&1
    fi
}

install_packages() {
    if echo "$system" | grep -qiE "centos|almalinux"; then lxc exec "$name" -- sudo yum install -y curl dos2unix >/dev/null 2>&1
    elif echo "$system" | grep -qiE "alpine"; then lxc exec "$name" -- apk add --no-cache curl >/dev/null 2>&1
    else lxc exec "$name" -- sudo apt-get install curl dos2unix -y >/dev/null 2>&1; fi
}

setup_ssh() {
    local st="bash"; echo "$system" | grep -qiE "alpine|openwrt" && st="sh"
    local sn="ssh_${st}.sh"
    # 使用 -O 强制覆盖文件
    [ ! -f "/usr/local/bin/$sn" ] && curl -L "${cdn_success_url}https://raw.githubusercontent.com/oneclickvirt/lxd/main/scripts/$sn" -o "/usr/local/bin/$sn" && chmod 777 "/usr/local/bin/$sn" && dos2unix "/usr/local/bin/$sn"
    lxc file push "/usr/local/bin/$sn" "$name"/root/; lxc exec "$name" -- chmod 777 "$sn"
    if [ "$st" == "sh" ]; then lxc exec "$name" -- ./"$sn" ${passwd}
    else
        lxc exec "$name" -- dos2unix "$sn"; lxc exec "$name" -- sudo ./"$sn" $passwd
        # config.sh
        [ ! -f /usr/local/bin/config.sh ] && curl -L ${cdn_success_url}https://raw.githubusercontent.com/oneclickvirt/lxd/main/scripts/config.sh -o /usr/local/bin/config.sh && chmod +x /usr/local/bin/config.sh && dos2unix /usr/local/bin/config.sh
        lxc file push /usr/local/bin/config.sh "$name"/root/; lxc exec "$name" -- bash config.sh; lxc exec "$name" -- history -c
    fi
}

configure_port() {
    echo -e "${SKYBLUE}配置网络...${PLAIN}"; [ "$is_vm" == true ] && mr=20 || mr=5
    for ((i=1; i<=mr; i++)); do sleep 5; container_ip=$(lxc list "$name" --format json | jq -r '.[0].state.network.eth0.addresses[]? | select(.family=="inet") | .address'); [ -n "$container_ip" ] && break; done
    if [ -z "$container_ip" ]; then echo -e "${RED}无IP，跳过端口映射${PLAIN}"; return; fi
    ipv4_address=$(ip addr show | awk '/inet .*global/ && !/inet6/ {print $2}' | sed -n '1p' | cut -d/ -f1)
    lxc config device override "$name" eth0 ipv4.address="$container_ip" 2>/dev/null || lxc config device set "$name" eth0 ipv4.address "$container_ip" 2>/dev/null
    lxc config device add "$name" ssh-port proxy listen=tcp:$ipv4_address:$sshn connect=tcp:$container_ip:22 nat=true
    if [ "$nat1" != "0" ] && [ "$nat2" != "0" ]; then
        lxc config device add "$name" nattcp-ports proxy listen=tcp:$ipv4_address:$nat1-$nat2 connect=tcp:0.0.0.0:$nat1-$nat2 nat=true
        lxc config device add "$name" natudp-ports proxy listen=udp:$ipv4_address:$nat1-$nat2 connect=udp:0.0.0.0:$nat1-$nat2 nat=true
    fi
}

configure_ipv6() {
    if [ "$enable_ipv6" == "y" ] && [ "$is_vm" == false ]; then
        [ ! -f "./build_ipv6_network.sh" ] && curl -L ${cdn_success_url}https://raw.githubusercontent.com/oneclickvirt/lxd/main/scripts/build_ipv6_network.sh -o build_ipv6_network.sh && chmod +x build_ipv6_network.sh
        ./build_ipv6_network.sh "$name"
    fi
}

configure_network_speed() {
    [ "$is_vm" == true ] && return
    lxc stop "$name" --timeout=30; sl=$(($in > $out ? $in : $out))
    lxc config device set "$name" eth0 limits.egress "$out"Mbit
    lxc config device set "$name" eth0 limits.ingress "$in"Mbit  
    lxc config device set "$name" eth0 limits.max "$sl"Mbit
    lxc start "$name"
}

cleanup_and_output() {
    # 再次清理临时文件
    rm -f lxd_image.zip lxd.tar.xz rootfs.squashfs
    
    clear
    echo "=================================================="
    echo -e "      ${GREEN}创建成功 (Created Successfully)${PLAIN}"
    echo "=================================================="
    echo -e " 名称:      ${SKYBLUE}$name${PLAIN}"
    echo -e " 区域:      ${SKYBLUE}$country_code${PLAIN}"
    echo -e " SSH 端口:  ${SKYBLUE}$sshn${PLAIN}"
    echo -e " ROOT 密码: ${SKYBLUE}$passwd${PLAIN}"
    [ "$nat1" != "0" ] && echo -e " NAT 端口:  ${SKYBLUE}$nat1 - $nat2${PLAIN}"
    echo "=================================================="
    lxc config set "$name" user.description "$name $sshn $passwd $nat1 $nat2"
    echo "$name $sshn $passwd $nat1 $nat2" >>"$name"
}

# --- 4. 实例列表功能 ---

view_instances() {
    clear
    echo "======================================================"
    echo -e "           ${GREEN}LXD 实例列表 (List Instances)${PLAIN}"
    echo "======================================================"
    local names=$(lxc list --format csv -c n)
    if [ -z "$names" ]; then
        echo -e "${YELLOW}当前没有任何实例。${PLAIN}"
        echo "======================================================"
        read -p "按回车返回主菜单..." dummy
        return
    fi
    for container in $names; do
        local info=$(lxc list "$container" --format json)
        local status=$(echo "$info" | jq -r '.[0].status')
        local ip=$(echo "$info" | jq -r '.[0].state.network.eth0.addresses[]? | select(.family=="inet") | .address')
        local type=$(echo "$info" | jq -r '.[0].type')
        local description=$(lxc config get "$container" user.description 2>/dev/null)
        local mem_limit=$(lxc config get "$container" limits.memory 2>/dev/null)
        local disk_limit=$(lxc config device get "$container" root size 2>/dev/null)
        read -r -a desc_arr <<< "$description"
        local show_ssh="${desc_arr[1]}"
        local show_pass="${desc_arr[2]}"
        local show_nat1="${desc_arr[3]}"
        local show_nat2="${desc_arr[4]}"
        [ -z "$ip" ] && ip="无 (Stopped/No IP)"
        [ -z "$mem_limit" ] && mem_limit="默认"
        [ -z "$disk_limit" ] && disk_limit="默认"
        if [ "$status" == "Running" ]; then status_color="${GREEN}$status${PLAIN}"; else status_color="${RED}$status${PLAIN}"; fi
        echo -e "${DIVIDER}"
        echo -e " 实例名称: ${SKYBLUE}${container}${PLAIN}  [${status_color}]  (${type})"
        echo -e " 内网 IP : ${ip}"
        echo -e " 硬件资源: 内存 ${YELLOW}${mem_limit}${PLAIN} / 硬盘 ${YELLOW}${disk_limit}${PLAIN}"
        if [ -n "$show_ssh" ] && [ -n "$show_pass" ]; then
            echo -e " SSH 端口: ${GREEN}${show_ssh}${PLAIN}"
            echo -e " Root密码: ${GREEN}${show_pass}${PLAIN}"
            if [ -n "$show_nat1" ] && [ "$show_nat1" != "0" ]; then
                echo -e " NAT 端口: ${SKYBLUE}${show_nat1} - ${show_nat2}${PLAIN}"
            else
                 echo -e " NAT 端口: 未启用"
            fi
        else
            echo -e "${YELLOW} (该实例非本脚本创建或元数据已丢失)${PLAIN}"
        fi
    done
    echo -e "${DIVIDER}"
    echo -e "提示: 密码仅为初始密码，手动修改后此处不会更新。"
    echo ""
    read -p "按回车返回主菜单..." dummy
}

# --- 5. 交互向导与入口 ---

start_creation_wizard() {
    clear
    echo "=================================================="
    echo -e "      ${GREEN}创建新实例 (Create New Instance)${PLAIN}"
    echo "=================================================="
    echo -e "当前节点: ${SKYBLUE}$country_code${PLAIN}"
    
    read -p "1. 实例名称 [默认: test]: " name; name=${name:-test}
    read -p "2. CPU核数 [默认: 1]: " cpu; cpu=${cpu:-1}
    read -p "3. 内存大小(MB) [默认: 256]: " memory; memory=${memory:-256}
    read -p "4. 硬盘大小(GB) [默认: 2]: " disk; disk=${disk:-2}

    echo -e "\n5. 操作系统:"
    echo -e "${SKYBLUE}--- Linux 容器 ---${PLAIN}                 ${SKYBLUE}--- 虚拟机 (VM) ---${PLAIN}"
    printf " %-35s %s\n" "1) Debian 12 (默认)" "8) Windows 11"
    printf " %-35s %s\n" "2) Debian 11"        "9) Windows 10"
    printf " %-35s %s\n" "3) Ubuntu 22.04"     "10) Windows Server 2022"
    printf " %-35s %s\n" "4) Ubuntu 20.04"     "11) Windows Server 2019"
    printf " %-35s %s\n" "5) CentOS 7"         "12) Debian 12 (VM)"
    printf " %-35s %s\n" "6) Alpine 3.18"      "13) Ubuntu 22.04 (VM)"
    printf " %-35s %s\n" "7) Kali Linux"       "14) 自定义"
    read -p "选择 [1-14]: " os_c
    is_vm=false
    case $os_c in
        2) system="debian11" ;; 3) system="ubuntu22.04" ;; 4) system="ubuntu20.04" ;; 5) system="centos7" ;; 6) system="alpine3.18" ;; 7) system="kali" ;;
        8) system="win11"; is_vm=true ;; 9) system="win10"; is_vm=true ;; 10) system="win2022"; is_vm=true ;; 11) system="win2019"; is_vm=true ;; 12) system="debian12"; is_vm=true ;; 13) system="ubuntu22.04"; is_vm=true ;;
        14) read -p "系统名: " system; read -p "是否VM(y/n): " temp_vm; [[ "$temp_vm" == "y" ]] && is_vm=true ;;
        *) system="debian12" ;;
    esac

    mirror_choice="off"
    if [ "$is_vm" == false ]; then
        echo -e "\n6. 镜像源策略:"
        echo -e " 1) ${GREEN}自动 (推荐)${PLAIN}"
        echo -e " 2) 强制国内"
        echo -e " 3) 强制国外"
        read -p "选择 [默认 1]: " m_in
        case $m_in in 2) mirror_choice="cn" ;; 3) mirror_choice="global" ;; *) mirror_choice="auto" ;; esac
    fi

    echo -e "\n7. 端口配置:"
    read -p "SSH 端口 [默认: 20001]: " sshn; sshn=${sshn:-20001}
    read -p "外网起始端口 (0禁用) [默认: 20002]: " nat1; nat1=${nat1:-20002}
    if [ "$nat1" == "0" ]; then nat2=0; else read -p "外网结束端口 [默认: 20025]: " nat2; nat2=${nat2:-20025}; fi

    echo -e "\n8. 网速:"
    read -p "限速 (Mbit) [默认: 10240]: " in; in=${in:-10240}; out=$in
    if [ "$is_vm" == false ]; then read -p "IPv6? (y/n): " enable_ipv6; fi

    # 再次检查 CDN，确保会话有效
    check_cdn_file

    a="${system%%[0-9]*}"; b="${system##*[!0-9.]}"
    get_system_arch
    
    # 流程执行
    process_image
    create_container
    configure_storage
    configure_resources
    setup_system
    configure_port
    configure_network_speed
    cleanup_and_output
    
    read -p "按回车返回主菜单..." dummy
}

main_menu() {
    while true; do
        clear
        echo "=================================================="
        echo -e "      ${GREEN}LXD 虚拟化管理脚本 (Fixed)${PLAIN}"
        echo "=================================================="
        echo -e " 1. ${SKYBLUE}创建新实例${PLAIN} (Create Instance)"
        echo -e " 2. ${SKYBLUE}查看所有实例${PLAIN} (View All Instances)"
        echo -e " 0. ${RED}退出脚本${PLAIN} (Exit)"
        echo "=================================================="
        read -p "请输入选项 [0-2]: " choice
        
        case $choice in
            1) start_creation_wizard ;;
            2) view_instances ;;
            0) exit 0 ;;
            *) echo -e "${RED}无效选项${PLAIN}"; sleep 1 ;;
        esac
    done
}

main() {
    init_env        # 清理旧文件
    check_lxd_env   # 修复 LXD 环境 (关键)
    detect_ip_info
    check_cdn_file
    main_menu
}

main "$@"
