#!/bin/bash
# ==============================================================================
# é¡¹ç›®: LXD Hub (Go å•ä½“ç‰ˆ) - ä¸€é”®å®‰è£…è„šæœ¬
# åŠŸèƒ½:
# - å®‰è£…/åˆå§‹åŒ– LXD (snap)
# - ç”Ÿæˆ mTLS è¯ä¹¦ (CA/Server/Client)
# - ç¼–è¯‘å¹¶éƒ¨ç½² Go æœåŠ¡ (ä¸€ä¸ªè¿›ç¨‹=Agent+Proxy+Panel)
# - :443  mTLS API
# - :18080 é¢æ¿+API (Header Token é‰´æƒ)
#
# è¿è¡Œç¯å¢ƒ: Debian 11+ / Ubuntu 20.04+ (Root)
# ==============================================================================

set -euo pipefail

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;36m'
PLAIN='\033[0m'

log() { echo -e "${BLUE}[*]${PLAIN} $*"; }
ok()  { echo -e "${GREEN}[OK]${PLAIN} $*"; }
warn(){ echo -e "${YELLOW}[!]${PLAIN} $*"; }
die() { echo -e "${RED}[X]${PLAIN} $*"; exit 1; }

[[ $EUID -ne 0 ]] && die "è¯·ä½¿ç”¨ root æƒé™è¿è¡Œ"

APP_DIR="/opt/lxd-hub"
BIN_PATH="${APP_DIR}/lxd-hub"
CERT_DIR="${APP_DIR}/certs"
DATA_DIR="${APP_DIR}/data"
PANEL_DIR="${APP_DIR}/panel"

MTLS_PORT="443"
PANEL_PORT="18080"

# ------------------------------------------------------------------------------
# 1) å®‰è£…ä¾èµ–
# ------------------------------------------------------------------------------
install_deps() {
  echo -e "${YELLOW}[1/6] å®‰è£…ä¾èµ–...${PLAIN}"
  export DEBIAN_FRONTEND=noninteractive
  apt-get update -qq
  apt-get install -y -qq curl jq openssl ufw ca-certificates >/dev/null

  # snapd
  if ! command -v snap >/dev/null 2>&1; then
    log "å®‰è£… snapd..."
    apt-get install -y -qq snapd >/dev/null
    systemctl enable --now snapd >/dev/null 2>&1 || true
  fi

  # Goï¼ˆç¼–è¯‘ç”¨ï¼‰
  if ! command -v go >/dev/null 2>&1; then
    log "å®‰è£… golangï¼ˆç”¨äºç¼–è¯‘ï¼‰..."
    apt-get install -y -qq golang >/dev/null
  fi

  ok "ä¾èµ–å°±ç»ª"
}

# ------------------------------------------------------------------------------
# 2) å®‰è£…/åˆå§‹åŒ– LXD
# ------------------------------------------------------------------------------
install_lxd() {
  echo -e "${YELLOW}[2/6] å®‰è£…/åˆå§‹åŒ– LXD...${PLAIN}"
  if ! command -v lxc >/dev/null 2>&1; then
    log "snap install lxd"
    snap install lxd >/dev/null
    log "lxd init --auto"
    lxd init --auto >/dev/null
  else
    ok "LXD å·²å­˜åœ¨"
  fi
}

# ------------------------------------------------------------------------------
# 3) ç”Ÿæˆè¯ä¹¦ + é¢æ¿ Token
# ------------------------------------------------------------------------------
generate_secrets() {
  echo -e "${YELLOW}[3/6] ç”Ÿæˆè¯ä¹¦ä¸é‰´æƒä¿¡æ¯...${PLAIN}"
  mkdir -p "${CERT_DIR}" "${DATA_DIR}" "${PANEL_DIR}"

  HOST_IP="$(hostname -I | awk '{print $1}')"
  [[ -z "${HOST_IP}" ]] && HOST_IP="127.0.0.1"

  # é¢æ¿ Tokenï¼ˆç”¨äº 18080 çš„ Header é‰´æƒï¼‰
  if [[ ! -f "${DATA_DIR}/panel.token" ]]; then
    openssl rand -hex 16 > "${DATA_DIR}/panel.token"
  fi

  # mTLS CA
  if [[ ! -f "${CERT_DIR}/ca.crt" ]]; then
    openssl genrsa -out "${CERT_DIR}/ca.key" 4096 2>/dev/null
    openssl req -x509 -new -nodes -key "${CERT_DIR}/ca.key" -days 3650 \
      -subj "/CN=LXD-Hub-CA" -out "${CERT_DIR}/ca.crt" 2>/dev/null
  fi

  # Server certï¼ˆmTLS æœåŠ¡ç«¯ï¼‰
  if [[ ! -f "${CERT_DIR}/server.crt" ]]; then
    openssl genrsa -out "${CERT_DIR}/server.key" 2048 2>/dev/null
    cat > "${CERT_DIR}/server.cnf" <<EOF
[req]
default_bits = 2048
prompt = no
default_md = sha256
distinguished_name = dn
req_extensions = req_ext
[dn]
CN = ${HOST_IP}
[req_ext]
subjectAltName = IP:${HOST_IP}
EOF
    openssl req -new -key "${CERT_DIR}/server.key" -config "${CERT_DIR}/server.cnf" \
      -out "${CERT_DIR}/server.csr" 2>/dev/null
    openssl x509 -req -in "${CERT_DIR}/server.csr" \
      -CA "${CERT_DIR}/ca.crt" -CAkey "${CERT_DIR}/ca.key" -CAcreateserial \
      -out "${CERT_DIR}/server.crt" -days 3650 \
      -extensions req_ext -extfile "${CERT_DIR}/server.cnf" 2>/dev/null
  fi

  # Client certï¼ˆå¤–éƒ¨è°ƒç”¨ 443 mTLS API ç”¨ï¼‰
  if [[ ! -f "${CERT_DIR}/client.crt" ]]; then
    openssl genrsa -out "${CERT_DIR}/client.key" 2048 2>/dev/null
    openssl req -new -key "${CERT_DIR}/client.key" -subj "/CN=LXD-Hub-Client" \
      -out "${CERT_DIR}/client.csr" 2>/dev/null
    openssl x509 -req -in "${CERT_DIR}/client.csr" \
      -CA "${CERT_DIR}/ca.crt" -CAkey "${CERT_DIR}/ca.key" -CAcreateserial \
      -out "${CERT_DIR}/client.crt" -days 3650 2>/dev/null
  fi

  chmod 644 "${CERT_DIR}"/*.crt
  chmod 600 "${CERT_DIR}"/*.key
  ok "è¯ä¹¦ä¸ Token å·²ç”Ÿæˆ"
}

# ------------------------------------------------------------------------------
# 4) å†™ Go æºç  + ç¼–è¯‘
# ------------------------------------------------------------------------------
build_go() {
  echo -e "${YELLOW}[4/6] ç¼–è¯‘ Go æœåŠ¡...${PLAIN}"
  mkdir -p "${APP_DIR}"
  cat > "${APP_DIR}/main.go" <<'EOF'
package main

import (
	"bytes"
	"context"
	"crypto/tls"
	"crypto/x509"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"net"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
	"time"
)

type ContainerReq struct {
	Name    string `json:"name"`
	Image   string `json:"image"`
	CPU     int    `json:"cpu"`
	Memory  int    `json:"memory"` // MB
	Disk    int    `json:"disk"`   // GB
	Ports   string `json:"ports"`  // "10001:22,10002:80"
	Ingress *int   `json:"ingress"`
	Egress  *int   `json:"egress"`
}

type Config struct {
	AppDir     string
	CertDir    string
	DataDir    string
	PanelDir   string
	MtlsPort   int
	PanelPort  int
	PanelToken string
}

func mustReadFile(path string) []byte {
	b, err := os.ReadFile(path)
	if err != nil {
		log.Fatalf("read file failed: %s: %v", path, err)
	}
	return b
}

func readToken(path string) string {
	b := mustReadFile(path)
	return strings.TrimSpace(string(b))
}

func writeJSON(w http.ResponseWriter, code int, v any) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	_ = json.NewEncoder(w).Encode(v)
}

func bad(w http.ResponseWriter, code int, msg string) {
	writeJSON(w, code, map[string]any{"error": msg})
}

func runCapture(timeout time.Duration, name string, args ...string) (string, error) {
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()

	cmd := exec.CommandContext(ctx, name, args...)
	var out bytes.Buffer
	var stderr bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &stderr

	err := cmd.Run()
	if ctx.Err() == context.DeadlineExceeded {
		return "", fmt.Errorf("command timeout: %s %v", name, args)
	}
	if err != nil {
		msg := strings.TrimSpace(stderr.String())
		if msg == "" {
			msg = strings.TrimSpace(out.String())
		}
		if msg == "" {
			msg = err.Error()
		}
		return "", fmt.Errorf("command failed: %s %v: %s", name, args, msg)
	}
	return out.String(), nil
}

func runOK(timeout time.Duration, name string, args ...string) error {
	_, err := runCapture(timeout, name, args...)
	return err
}

func validateReq(r *ContainerReq) error {
	if strings.TrimSpace(r.Name) == "" {
		return errors.New("name required")
	}
	if r.Image == "" {
		r.Image = "images:debian/11"
	}
	if r.CPU <= 0 || r.CPU > 128 {
		return errors.New("cpu must be 1..128")
	}
	if r.Memory < 128 || r.Memory > 1048576 {
		return errors.New("memory(MB) must be 128..1048576")
	}
	if r.Disk < 1 || r.Disk > 1048576 {
		return errors.New("disk(GB) must be 1..1048576")
	}
	if r.Ingress != nil && (*r.Ingress < 1 || *r.Ingress > 100000) {
		return errors.New("ingress Mbps must be 1..100000")
	}
	if r.Egress != nil && (*r.Egress < 1 || *r.Egress > 100000) {
		return errors.New("egress Mbps must be 1..100000")
	}
	return nil
}

func apiList(w http.ResponseWriter, _ *http.Request) {
	out, err := runCapture(20*time.Second, "lxc", "list", "--format", "json")
	if err != nil {
		bad(w, 500, err.Error())
		return
	}
	var v any
	if err := json.Unmarshal([]byte(out), &v); err != nil {
		bad(w, 500, "failed to parse lxc list output")
		return
	}
	writeJSON(w, 200, v)
}

func apiCreate(w http.ResponseWriter, req *http.Request) {
	body, _ := io.ReadAll(io.LimitReader(req.Body, 2<<20))
	var c ContainerReq
	if err := json.Unmarshal(body, &c); err != nil {
		bad(w, 400, "invalid json")
		return
	}
	if c.Image == "" {
		c.Image = "images:debian/11"
	}
	if c.CPU == 0 {
		c.CPU = 1
	}
	if c.Memory == 0 {
		c.Memory = 512
	}
	if c.Disk == 0 {
		c.Disk = 5
	}
	if err := validateReq(&c); err != nil {
		bad(w, 400, err.Error())
		return
	}

	// 1) launch
	if err := runOK(180*time.Second, "lxc", "launch", c.Image, c.Name); err != nil {
		bad(w, 500, err.Error())
		return
	}

	// 2) limits
	_ = runOK(15*time.Second, "lxc", "config", "set", c.Name, "limits.cpu", strconv.Itoa(c.CPU))
	_ = runOK(15*time.Second, "lxc", "config", "set", c.Name, "limits.memory", fmt.Sprintf("%dMB", c.Memory))

	// 3) disk
	if err := runOK(15*time.Second, "lxc", "config", "device", "set", c.Name, "root", "size", fmt.Sprintf("%dGB", c.Disk)); err != nil {
		_ = runOK(15*time.Second, "lxc", "config", "device", "override", c.Name, "root", fmt.Sprintf("size=%dGB", c.Disk))
	}

	// 4) net limits (eth0)
	if c.Ingress != nil {
		_ = runOK(15*time.Second, "lxc", "config", "device", "override", c.Name, "eth0", fmt.Sprintf("limits.ingress=%dMbit", *c.Ingress))
	}
	if c.Egress != nil {
		_ = runOK(15*time.Second, "lxc", "config", "device", "override", c.Name, "eth0", fmt.Sprintf("limits.egress=%dMbit", *c.Egress))
	}

	// 5) ports proxy device
	if strings.TrimSpace(c.Ports) != "" {
		maps := strings.Split(c.Ports, ",")
		idx := 0
		for _, m := range maps {
			m = strings.TrimSpace(m)
			if m == "" || !strings.Contains(m, ":") {
				continue
			}
			parts := strings.SplitN(m, ":", 2)
			pub := strings.TrimSpace(parts[0])
			priv := strings.TrimSpace(parts[1])
			if pub == "" || priv == "" {
				continue
			}
			if _, err := strconv.Atoi(pub); err != nil {
				continue
			}
			if _, err := strconv.Atoi(priv); err != nil {
				continue
			}
			devName := fmt.Sprintf("proxy%d", idx)
			// connect åˆ°å®¹å™¨ 127.0.0.1:privï¼ˆä¸ä½ åŸé€»è¾‘ä¸€è‡´ï¼‰
			_ = runOK(15*time.Second, "lxc", "config", "device", "add", c.Name, devName, "proxy",
				fmt.Sprintf("listen=tcp:0.0.0.0:%s", pub),
				fmt.Sprintf("connect=tcp:127.0.0.1:%s", priv),
			)
			idx++
		}
	}

	writeJSON(w, 200, map[string]any{"status": "created", "name": c.Name})
}

func apiDelete(w http.ResponseWriter, name string) {
	if strings.TrimSpace(name) == "" {
		bad(w, 400, "name required")
		return
	}
	if err := runOK(60*time.Second, "lxc", "delete", name, "--force"); err != nil {
		bad(w, 500, err.Error())
		return
	}
	writeJSON(w, 200, map[string]any{"status": "deleted", "name": name})
}

func apiAction(w http.ResponseWriter, name, action string) {
	action = strings.ToLower(strings.TrimSpace(action))
	if action != "start" && action != "stop" && action != "restart" {
		bad(w, 400, "invalid action")
		return
	}
	if strings.TrimSpace(name) == "" {
		bad(w, 400, "name required")
		return
	}
	if err := runOK(60*time.Second, "lxc", action, name); err != nil {
		bad(w, 500, err.Error())
		return
	}
	writeJSON(w, 200, map[string]any{"status": "ok", "name": name, "action": action})
}

func withPanelToken(token string, next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// é¢æ¿ä¸é¢æ¿ API ç»Ÿä¸€ç”¨ Header Token
		if r.URL.Path == "/health" {
			next.ServeHTTP(w, r)
			return
		}
		got := r.Header.Get("X-Panel-Token")
		if got != token {
			bad(w, 401, "missing/invalid X-Panel-Token")
			return
		}
		next.ServeHTTP(w, r)
	})
}

func router(cfg Config) http.Handler {
	mux := http.NewServeMux()

	// health
	mux.HandleFunc("/health", func(w http.ResponseWriter, _ *http.Request) {
		writeJSON(w, 200, map[string]any{"ok": true})
	})

	// Panel staticï¼ˆç®€å•èµ·è§ï¼šé¢æ¿ HTML æ–‡ä»¶ï¼‰
	mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		// åªæä¾›é¢æ¿æ–‡ä»¶
		if r.URL.Path != "/" && r.URL.Path != "/panel.html" {
			http.NotFound(w, r)
			return
		}
		p := filepath.Join(cfg.PanelDir, "panel.html")
		b, err := os.ReadFile(p)
		if err != nil {
			bad(w, 500, "panel not found")
			return
		}
		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		_, _ = w.Write(b)
	})

	// API
	mux.HandleFunc("/api/list", func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodGet {
			bad(w, 405, "method not allowed")
			return
		}
		apiList(w, r)
	})

	mux.HandleFunc("/api/create", func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			bad(w, 405, "method not allowed")
			return
		}
		apiCreate(w, r)
	})

	mux.HandleFunc("/api/delete/", func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodDelete {
			bad(w, 405, "method not allowed")
			return
		}
		name := strings.TrimPrefix(r.URL.Path, "/api/delete/")
		apiDelete(w, name)
	})

	mux.HandleFunc("/api/action/", func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			bad(w, 405, "method not allowed")
			return
		}
		rest := strings.TrimPrefix(r.URL.Path, "/api/action/")
		parts := strings.Split(rest, "/")
		if len(parts) != 2 {
			bad(w, 400, "path must be /api/action/{name}/{action}")
			return
		}
		apiAction(w, parts[0], parts[1])
	})

	return mux
}

func loadTLSConfig(certDir string) (*tls.Config, error) {
	caPEM, err := os.ReadFile(filepath.Join(certDir, "ca.crt"))
	if err != nil {
		return nil, err
	}
	cert, err := tls.LoadX509KeyPair(filepath.Join(certDir, "server.crt"), filepath.Join(certDir, "server.key"))
	if err != nil {
		return nil, err
	}
	caPool := x509.NewCertPool()
	if !caPool.AppendCertsFromPEM(caPEM) {
		return nil, errors.New("failed to append ca")
	}
	return &tls.Config{
		Certificates: []tls.Certificate{cert},
		ClientCAs:    caPool,
		ClientAuth:   tls.RequireAndVerifyClientCert,
		MinVersion:   tls.VersionTLS12,
	}, nil
}

func localIP() string {
	ifaces, _ := net.Interfaces()
	for _, iface := range ifaces {
		addrs, _ := iface.Addrs()
		for _, a := range addrs {
			ipnet, ok := a.(*net.IPNet)
			if !ok || ipnet.IP == nil {
				continue
			}
			ip := ipnet.IP.To4()
			if ip == nil {
				continue
			}
			s := ip.String()
			if s != "127.0.0.1" {
				return s
			}
		}
	}
	return "127.0.0.1"
}

func main() {
	cfg := Config{
		AppDir:    "/opt/lxd-hub",
		CertDir:   "/opt/lxd-hub/certs",
		DataDir:   "/opt/lxd-hub/data",
		PanelDir:  "/opt/lxd-hub/panel",
		MtlsPort:  443,
		PanelPort: 18080,
	}

	// env overrideï¼ˆå¯é€‰ï¼‰
	if v := os.Getenv("MTLS_PORT"); v != "" {
		if p, _ := strconv.Atoi(v); p > 0 {
			cfg.MtlsPort = p
		}
	}
	if v := os.Getenv("PANEL_PORT"); v != "" {
		if p, _ := strconv.Atoi(v); p > 0 {
			cfg.PanelPort = p
		}
	}
	cfg.PanelToken = readToken(filepath.Join(cfg.DataDir, "panel.token"))

	// Router
	base := router(cfg)

	// Panel serverï¼ˆéœ€è¦ Tokenï¼‰
	panelSrv := &http.Server{
		Addr:              fmt.Sprintf("0.0.0.0:%d", cfg.PanelPort),
		Handler:           withPanelToken(cfg.PanelToken, base),
		ReadTimeout:       15 * time.Second,
		ReadHeaderTimeout: 10 * time.Second,
		WriteTimeout:      60 * time.Second,
		IdleTimeout:       60 * time.Second,
	}

	// mTLS serverï¼ˆå¼ºè®¤è¯ï¼Œä¸éœ€è¦ PanelTokenï¼‰
	mtlsTLS, err := loadTLSConfig(cfg.CertDir)
	if err != nil {
		log.Fatalf("tls config error: %v", err)
	}
	mtlsSrv := &http.Server{
		Addr:              fmt.Sprintf("0.0.0.0:%d", cfg.MtlsPort),
		Handler:           base,
		TLSConfig:         mtlsTLS,
		ReadTimeout:       15 * time.Second,
		ReadHeaderTimeout: 10 * time.Second,
		WriteTimeout:      60 * time.Second,
		IdleTimeout:       60 * time.Second,
	}

	// å¯åŠ¨
	go func() {
		log.Printf("Panel+API: http://0.0.0.0:%d (requires X-Panel-Token)", cfg.PanelPort)
		if err := panelSrv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("panel server error: %v", err)
		}
	}()

	log.Printf("mTLS API: https://0.0.0.0:%d (client cert required)", cfg.MtlsPort)
	ln, err := net.Listen("tcp", mtlsSrv.Addr)
	if err != nil {
		log.Fatalf("listen mtls error: %v", err)
	}
	tlsLn := tls.NewListener(ln, mtlsTLS)
	if err := mtlsSrv.Serve(tlsLn); err != nil && err != http.ErrServerClosed {
		log.Fatalf("mtls server error: %v", err)
	}

	_ = localIP()
}
EOF

  # å†™å‰ç«¯ panel.htmlï¼ˆä¿æŒâ€œé™æ€+é›¶æ„å»ºâ€ï¼‰
  cat > "${PANEL_DIR}/panel.html" <<'EOF'
<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>LXD Hub Panel</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-slate-950 text-slate-100">
<div id="app" class="max-w-6xl mx-auto p-6 space-y-6">
  <header class="flex items-center justify-between">
    <div>
      <h1 class="text-2xl font-semibold">LXD Hub ç®¡ç†é¢æ¿</h1>
      <p class="text-slate-400 text-sm">Go å•ä½“æœåŠ¡ï¼šä¸€ä¸ªè¿›ç¨‹æŠŠäº‹æƒ…å¹²æ¼‚äº®ã€‚ğŸ§©</p>
    </div>
    <div class="flex items-center gap-2">
      <input v-model="base" class="w-72 px-3 py-2 rounded-xl bg-slate-900 border border-slate-700"
             placeholder="ä¾‹å¦‚ http://1.2.3.4:18080" />
      <input v-model="token" class="w-72 px-3 py-2 rounded-xl bg-slate-900 border border-slate-700"
             placeholder="X-Panel-Tokenï¼ˆå®‰è£…è„šæœ¬ä¼šè¾“å‡ºï¼‰" />
      <button @click="refresh" class="px-4 py-2 rounded-xl bg-slate-100 text-slate-900 font-semibold">åˆ·æ–°</button>
    </div>
  </header>

  <section class="grid grid-cols-1 lg:grid-cols-3 gap-6">
    <div class="lg:col-span-1 rounded-2xl border border-slate-800 bg-slate-900/40 p-5">
      <h2 class="text-lg font-semibold mb-4">åˆ›å»ºå®¹å™¨</h2>
      <div class="space-y-3">
        <div>
          <label class="text-sm text-slate-300">åç§°</label>
          <input v-model="form.name" class="w-full px-3 py-2 rounded-xl bg-slate-950 border border-slate-800" placeholder="demo-01"/>
        </div>
        <div>
          <label class="text-sm text-slate-300">é•œåƒ</label>
          <input v-model="form.image" class="w-full px-3 py-2 rounded-xl bg-slate-950 border border-slate-800" placeholder="images:debian/11"/>
        </div>
        <div class="grid grid-cols-3 gap-2">
          <div><label class="text-sm text-slate-300">CPU</label>
            <input v-model.number="form.cpu" type="number" min="1" class="w-full px-3 py-2 rounded-xl bg-slate-950 border border-slate-800"/></div>
          <div><label class="text-sm text-slate-300">å†…å­˜(MB)</label>
            <input v-model.number="form.memory" type="number" min="128" class="w-full px-3 py-2 rounded-xl bg-slate-950 border border-slate-800"/></div>
          <div><label class="text-sm text-slate-300">ç£ç›˜(GB)</label>
            <input v-model.number="form.disk" type="number" min="1" class="w-full px-3 py-2 rounded-xl bg-slate-950 border border-slate-800"/></div>
        </div>
        <div class="grid grid-cols-2 gap-2">
          <div><label class="text-sm text-slate-300">å…¥ç«™(Mbps)</label>
            <input v-model.number="form.ingress" type="number" min="0" class="w-full px-3 py-2 rounded-xl bg-slate-950 border border-slate-800" placeholder="å¯ç©º"/></div>
          <div><label class="text-sm text-slate-300">å‡ºç«™(Mbps)</label>
            <input v-model.number="form.egress" type="number" min="0" class="w-full px-3 py-2 rounded-xl bg-slate-950 border border-slate-800" placeholder="å¯ç©º"/></div>
        </div>
        <div>
          <label class="text-sm text-slate-300">ç«¯å£æ˜ å°„</label>
          <input v-model="form.ports" class="w-full px-3 py-2 rounded-xl bg-slate-950 border border-slate-800" placeholder="10001:22,10002:80 å¯ç©º"/>
        </div>
        <button @click="create" class="w-full px-4 py-2 rounded-xl bg-emerald-400 text-slate-900 font-semibold">åˆ›å»º</button>
        <p v-if="notice" class="text-sm text-slate-300"><span class="text-slate-400">æç¤ºï¼š</span>{{notice}}</p>
      </div>
    </div>

    <div class="lg:col-span-2 rounded-2xl border border-slate-800 bg-slate-900/40 p-5">
      <div class="flex items-center justify-between mb-4">
        <h2 class="text-lg font-semibold">å®¹å™¨åˆ—è¡¨</h2>
        <div class="flex items-center gap-2">
          <input v-model="filter" class="px-3 py-2 rounded-xl bg-slate-950 border border-slate-800" placeholder="æœç´¢åç§°..."/>
          <span class="text-sm text-slate-400">å…± {{ filtered.length }} ä¸ª</span>
        </div>
      </div>

      <div v-if="loading" class="text-slate-400">åŠ è½½ä¸­...</div>
      <div v-else class="space-y-3">
        <div v-for="c in filtered" :key="c.name"
             class="rounded-2xl border border-slate-800 bg-slate-950/40 p-4 flex items-center justify-between gap-4">
          <div class="min-w-0">
            <div class="flex items-center gap-2">
              <div class="font-semibold truncate">{{ c.name }}</div>
              <span class="text-xs px-2 py-1 rounded-full"
                    :class="c.status==='Running' ? 'bg-emerald-500/20 text-emerald-300 border border-emerald-500/30'
                                                 : 'bg-amber-500/20 text-amber-300 border border-amber-500/30'">
                {{ c.status }}
              </span>
            </div>
            <div class="text-sm text-slate-400 mt-1 truncate">IPv4: {{ c.ipv4 || '-' }} Â· Image: {{ c.image || '-' }}</div>
          </div>

          <div class="flex items-center gap-2 shrink-0">
            <button @click="act(c.name,'start')" class="px-3 py-2 rounded-xl bg-slate-100 text-slate-900 font-semibold">Start</button>
            <button @click="act(c.name,'stop')" class="px-3 py-2 rounded-xl bg-slate-800 text-slate-100 border border-slate-700">Stop</button>
            <button @click="act(c.name,'restart')" class="px-3 py-2 rounded-xl bg-slate-800 text-slate-100 border border-slate-700">Restart</button>
            <button @click="del(c.name)" class="px-3 py-2 rounded-xl bg-rose-500/90 text-white font-semibold">Delete</button>
          </div>
        </div>

        <div v-if="!filtered.length" class="text-slate-400">æ²¡æœ‰åŒ¹é…çš„å®¹å™¨ã€‚</div>
      </div>

      <div v-if="error" class="mt-4 rounded-xl border border-rose-800 bg-rose-950/40 p-3 text-rose-200 text-sm">{{ error }}</div>
    </div>
  </section>

  <footer class="text-xs text-slate-500">
    é¢æ¿é€šè¿‡ Header: X-Panel-Token é‰´æƒï¼›443 ç«¯å£ä¸º mTLS å¼ºè®¤è¯ APIï¼ˆç»™å¤–éƒ¨ç¨‹åºç”¨ï¼‰ã€‚
  </footer>
</div>

<script>
const { createApp } = Vue;
createApp({
  data(){
    return {
      base: "http://127.0.0.1:18080",
      token: "",
      loading:false,
      error:"",
      notice:"",
      filter:"",
      containers:[],
      form:{ name:"", image:"images:debian/11", cpu:1, memory:512, disk:5, ports:"", ingress:null, egress:null }
    }
  },
  computed:{
    filtered(){
      const kw=this.filter.trim().toLowerCase();
      return this.containers.filter(x=>!kw||x.name.toLowerCase().includes(kw));
    }
  },
  methods:{
    async api(path, opt={}){
      const url=this.base.replace(/\/+$/,"")+path;
      const res=await fetch(url,{
        headers:{ "Content-Type":"application/json", "X-Panel-Token": this.token },
        ...opt
      });
      const data=await res.json().catch(()=>({}));
      if(!res.ok) throw new Error(data?.error || data?.detail || `HTTP ${res.status}`);
      return data;
    },
    normalize(raw){
      return (raw||[]).map(it=>{
        const name=it?.name||it?.Name||"unknown";
        const status=String(it?.status||it?.Status||it?.state?.status||"Unknown");
        const image=it?.config?.["image.description"]||it?.expanded_config?.["image.description"]||"";
        let ipv4="";
        try{
          const net=it?.state?.network||{};
          for(const nic of Object.values(net)){
            const addrs=nic?.addresses||[];
            const v4=addrs.find(a=>a.family==="inet");
            if(v4?.address){ ipv4=v4.address; break; }
          }
        }catch(e){}
        return {name,status,ipv4,image};
      }).sort((a,b)=>a.name.localeCompare(b.name));
    },
    async refresh(){
      this.error=""; this.notice=""; this.loading=true;
      try{
        const raw=await this.api("/api/list",{method:"GET"});
        this.containers=this.normalize(raw);
      }catch(e){ this.error=String(e.message||e); }
      finally{ this.loading=false; }
    },
    async create(){
      this.error=""; this.notice="";
      if(!this.form.name.trim()){ this.notice="å®¹å™¨åä¸èƒ½ä¸ºç©º"; return; }
      const p={...this.form};
      if(!p.ports) delete p.ports;
      if(!p.ingress) delete p.ingress;
      if(!p.egress) delete p.egress;
      try{
        await this.api("/api/create",{method:"POST",body:JSON.stringify(p)});
        this.notice="åˆ›å»ºå·²æäº¤ï¼Œç¨ç­‰åˆ·æ–°ã€‚";
        await this.refresh();
      }catch(e){ this.error=String(e.message||e); }
    },
    async act(name,action){
      this.error="";
      try{
        await this.api(`/api/action/${encodeURIComponent(name)}/${encodeURIComponent(action)}`,{method:"POST"});
        await this.refresh();
      }catch(e){ this.error=String(e.message||e); }
    },
    async del(name){
      this.error="";
      if(!confirm(`ç¡®è®¤åˆ é™¤ ${name}ï¼Ÿä¸å¯é€†ã€‚`)) return;
      try{
        await this.api(`/api/delete/${encodeURIComponent(name)}`,{method:"DELETE"});
        await this.refresh();
      }catch(e){ this.error=String(e.message||e); }
    }
  },
  mounted(){ /* ä¸è‡ªåŠ¨åˆ·æ–°ï¼Œé¿å…æ²¡å¡« token å°±æŠ¥é”™ */ }
}).mount("#app");
</script>
</body>
</html>
EOF

  (cd "${APP_DIR}" && go build -o "${BIN_PATH}" main.go)
  chmod +x "${BIN_PATH}"
  ok "ç¼–è¯‘å®Œæˆï¼š${BIN_PATH}"
}

# ------------------------------------------------------------------------------
# 5) systemd æœåŠ¡
# ------------------------------------------------------------------------------
install_service() {
  echo -e "${YELLOW}[5/6] é…ç½® systemd æœåŠ¡...${PLAIN}"
  cat > /etc/systemd/system/lxd-hub.service <<EOF
[Unit]
Description=LXD Hub (Go single binary) - Panel+API + mTLS API
After=network.target snap.lxd.daemon.service
Wants=snap.lxd.daemon.service

[Service]
WorkingDirectory=${APP_DIR}
ExecStart=${BIN_PATH}
Restart=always
RestartSec=2
# å¯é€‰ï¼šè¦†ç›–ç«¯å£
Environment=MTLS_PORT=${MTLS_PORT}
Environment=PANEL_PORT=${PANEL_PORT}

[Install]
WantedBy=multi-user.target
EOF

  systemctl daemon-reload
  systemctl enable --now lxd-hub >/dev/null
  ok "æœåŠ¡å·²å¯åŠ¨ï¼šlxd-hub"
}

# ------------------------------------------------------------------------------
# 6) æ”¾è¡Œç«¯å£ + è¾“å‡ºä¿¡æ¯
# ------------------------------------------------------------------------------
configure_firewall_and_print() {
  echo -e "${YELLOW}[6/6] é…ç½®é˜²ç«å¢™ä¸è¾“å‡ºä¿¡æ¯...${PLAIN}"
  ufw allow 22/tcp >/dev/null 2>&1 || true
  ufw allow "${MTLS_PORT}/tcp" >/dev/null 2>&1 || true
  ufw allow "${PANEL_PORT}/tcp" >/dev/null 2>&1 || true

  HOST_IP="$(hostname -I | awk '{print $1}')"
  [[ -z "${HOST_IP}" ]] && HOST_IP="127.0.0.1"
  PANEL_TOKEN="$(cat "${DATA_DIR}/panel.token")"

  # mTLS Tokenï¼ˆç»™å¤–éƒ¨ç¨‹åº/åˆ«çš„é¢æ¿å¯¼å…¥ç”¨ï¼‰
  JSON_DATA="$(jq -n \
    --arg url "https://${HOST_IP}:${MTLS_PORT}" \
    --arg ca "$(cat ${CERT_DIR}/ca.crt)" \
    --arg cert "$(cat ${CERT_DIR}/client.crt)" \
    --arg key "$(cat ${CERT_DIR}/client.key)" \
    '{api_url:$url, ca_cert:$ca, client_cert:$cert, client_key:$key}')"
  MTLS_TOKEN="$(echo "$JSON_DATA" | base64 -w0)"

  echo -e "\n${GREEN}==============================================${PLAIN}"
  echo -e "${GREEN}  LXD Hub å®‰è£…å®Œæˆï¼ˆGo å•ä½“ç‰ˆï¼‰${PLAIN}"
  echo -e "${GREEN}==============================================${PLAIN}"
  echo -e "é¢æ¿åœ°å€:     http://${HOST_IP}:${PANEL_PORT}   ï¼ˆéœ€è¦ X-Panel-Tokenï¼‰"
  echo -e "é¢æ¿æ–‡ä»¶:     ${PANEL_DIR}/panel.html"
  echo -e "é¢æ¿ Token:   ${YELLOW}${PANEL_TOKEN}${PLAIN}"
  echo -e ""
  echo -e "mTLS API:     https://${HOST_IP}:${MTLS_PORT}   ï¼ˆå®¢æˆ·ç«¯è¯ä¹¦è®¤è¯ï¼‰"
  echo -e "mTLS å¯¼å…¥Tokenï¼ˆå«è¯ä¹¦ï¼‰:"
  echo -e "${YELLOW}${MTLS_TOKEN}${PLAIN}"
  echo -e ""
  warn "å®‰å…¨å»ºè®®ï¼š18080 ä»å»ºè®®åªå¯¹å†…ç½‘å¼€æ”¾ï¼Œæˆ–ä½ è®©æˆ‘åŠ  IP ç™½åå•/HTTPS/ç™»å½•ã€‚"
}

# ------------------------------------------------------------------------------
# Run
# ------------------------------------------------------------------------------
install_deps
install_lxd
generate_secrets
build_go
install_service
configure_firewall_and_print
